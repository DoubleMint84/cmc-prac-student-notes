# Семинар №1 - Введение

С++ - "улучшение" языка Си. Кроме многих положительных сторон языка Си плюсы позаимствовали у него также и UB! Но, тем не менее, полная обратная совместимость обеспечена.

Компилятор g++ такой же, как gcc, только для плюсов. Последняя версия - 13, поддерживающая последний стандарт C++23

Лучший справочник - [cppreference](https://en.cppreference.com/w/)

[cpp core guidelines](https://github.com/isocpp/CppCoreGuidelines) - кодстайл от автора языка (каждая компания почему-то создает свой кодстайл)

[draft report](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4849.pdf) - черновик стандарта (рассылаются бесплатно в компании, которые участвуют в развитии языка). 2-4к страниц

Почему некоторым не нравится направление развития плюсов? плюсы начинают двигаться в сторону питона (!)

Совет: начните изучать rust. В будущем пригодится :)

### Рекомендуемая литература:
Александреску Андрей. Современное проектирование на C++. https://www.ozon.ru/context/detail/id/148627175/ ISBN: 978-5-907114-24-1

Прата Стивен. Язык программирования C++. Лекции и упражнения. https://www.ozon.ru/context/detail/id/147417584/ ISBN: 978-5-907114-00-5

## От слов к делу

### Стандартный toolset для работы с плюсами

makefile:
```makefile
#
CXX = g++
CXXFLAGS = -g -Wall -Werror -std=gnu++20 -D_GNU_SOURCE

# Расширения файлов для кода на C++: .cpp, .cc, .cxx, .C
# Расширения файлов для хэдеров: .h, .hpp, .hh

test1:  test1.cpp
```

#### За что могут зареджектить задачу:
- За использование `using namespace std`
- За подключение `bits/stdc++.h` (Бан!). Подключаем только те библиотеки, которые используются в программе.
- За использование scanf и printf там, где не нужно. Пользуемся стандартными плюсовыми потоками `std::cin`, `std::cout` и `std::cerr`

Почему стоит писать `std::endl` вместо `\n`? Потому что первый выводит `\n` И СРАЗУ ЖЕ сбрасывает буфер, в отличие от второго.

А теперь напишем простейшую программу на плюсах:

test1.cpp:
```cpp
#include <iostream> // Библиотека для ввода-вывода

int 
main()
{
    int a, b; // Интересный факт: в C++ даже int является классом
    std::cin >> a >> b; // std::cin --> var
    std::cout << "Result = " << a + b << std::endl; // var --> std::cout
}
```

Компиляция осуществляется как всегда через запуск команды `make`.

Здесь потоки `cin`, `cout`, `cerr` находятся внутри пространства имен `std` (про неймспесы читай ниже)

Заметим, что `std::cin` также является классом. Как можно переписать этот код:

```cpp
#include <iostream>

int 
main()
{
    int a, b; 
    std::cin.operator>>(a).operator>>(b);
    std::cout << "Result = " << a + b << std::endl; 
}
```

### namespace

В пространствах имен можно группировать имена переменных.

```cpp
#include <iostream>

int b; // Глобальная переменная, будет видна во всем scope

namespace A
{
    int a;
    int b;
} // Перекрытия не произойдет: две разные переменные b и A::b

int main()
{
    int a, b = 2;
    std::cin >> A::a; // Переменная a из пространства A
    std::cin >> ::b; // "анонимный" неймспейс -
    // - тут будет обращение к глобальной переменной b
    std::cout << "b = " << b << std::endl; 
    // Вывод значения локальной переменной b = 2
}
```

Можно создавать вложенные неймспейсы, но лучше так не делать - ухудшается читаемость кода:

Плохо:
```
#include <iostream>

namespace A
{
    int a;
    int b;
    namespace B
    {
        int c;
    }
}

int main() 
{
    int a, b = 2;
    std::cin >> A::a >> ::b;
    std::cout << "b = " << ::b << std::endl;
    A::B::c = A::a * ::b;
}
```

Как лучше делать:
```cpp
int b = 0;
namespace A
{    
    int a;    
    int b;
    /*namespace B
    {
        int c;
    }*/
}

namespace A::B
{
    int c;
}

namespace AB = A::B;    // Мы можем использовать сокращенное 
                        // имя пространства имен

int main()
{
    int a, b = 2;
    std::cin >> A::a >> ::b;
    std::cout << "b = " << ::b << std::endl;
    A::B::c = A::a * ::b;
    AB::c = AB::с * 2; // AB::c эквивалентно A::B::c
}
```

### Анонимные неймспейсы

Как вы уже знаете, задавать глобальные переменные плохо:
```
static int d;
```

В качестве удобной альтернативы используем анонимный неймспейс:
```cpp
namespace
{
    int d; // Обращаемся к ней через ::d
}
```

### Функции в неймспейсах
В пространствах имен можно задавать функции:

```cpp
#include <iostream>

namespace A
{
    int f(int x)
    {
        return x * x;
    }
}

int main()
{
    std::cout << AB::f(-5) << std::endl;
}
```

Примера использования `using namespace std` не будет, так как за него предусмотрен БАН.

Хотя ладно уж, будет:
```
#include <iostream>

using namespace std;

namespace A
{
    int f(int x)
    {
        return x * x;
    }
}

int main()
{
    cout << AB::f(-5) << endl;
}
```

Учитывая, что в пространстве std находится куча различных переменных и функций, про существование которых вы, возможно, даже не догадываетесь. В случае, когда вы назовете свою собственную функцию так же, компилятор будет думать над тем, какую функцию - вашу собственную или библиотечную - использовать. Будет неприятно, когда компилятор сделает выбор в пользу библиотечной функции, уж поверьте.

В качестве еще одного весомого аргумента против `using namespace std` можно обратиться ко мнению самого автора языка Бьерна Страуступа: он категорически не рекомендует использовать *это*.

#### Как еще можно использовать using

```cpp
using std::cin, std::cout;

int main () {
    // Здесь уже можно писать просто cin, cout

    // Опять же, такой код могут зареджектить, 
    // так что будьте осторожнее с этим
}
```

### using в качестве альтернативы typedef
Начиная с 11 стандарта, появилась крутая альтернатива typedef с использованием using:

```cpp
using myInt = int;

int main() {
    myInt aa, bb;   // В отличие от typedef, никакого нового типа 
                    // не вводится!
}
```
Подробнее про using читай [здесь](https://en.cppreference.com/w/cpp/language/using_declaration).

## Атрибуты
Атрибуты задают дополнительную информацию для различных конструкций языка. По сути, являются подсказками для компилятора.

Пример:
```cpp
[[maybe_unused]] myInt aa, bb; // Эти переменные могут не использоваться, при этом компилятор не будет кидать warning.
```

[Про атрибуты подробнее...](https://ru.stackoverflow.com/a/662432)

## Типы в C++
По сути являются классами. Кроме того, появилась КУЧА способов инициализировать переменные:

```cpp
#include <iostream>

int main()
{
    int64_t sum1 = 0; // Стандартное объявление
    int64_t sum2(0); // Здесь будет вызван конструктор по значению
    int64_t sum3 = int64_t();   // Конструктор по умолчанию 
                                // (лучше так не писать)
    std::cout << "sum = " << sum3 << std::endl; 
    // Вроде выведет ноль, но это не точно
    std::cout << "size of int" << sizeof(sum3) << std::endl; 
    // выведет 8 (зависит от машины)

    int64_t sum4{0}; // Списки инициализации 
    // (удобно, когда объект с множеством полей)
    int64_t sum5{}; 
}
```

Про типы подробнее читай [здесь](https://en.cppreference.com/w/cpp/language/types).

### bool 
Кстати, в C++ появился bool по умолчанию!

Как всегда принимает два значения: true и false.

Однако результат `sizeof(bool)` является implementation defined и может отличаться от 1.

## Как проверить, что поток ввода не закрыт?

```cpp
int tmp;
while (std::cin >> tmp) {
    sum += tmp;
}

while (!(std::cin >> tmp).eof()) {
    // ...
}

// Аналог цикла выше, за который можно получить БАН (или реджект)
while (true)
{
    std::cin >> tmp;
    if (std::cin.eof()) break;
    sum += tmp;
}
```

## iomanip

Данная библиотека добавляет некоторые удобства в выводе значений

```cpp
#include <iostream> // input-output stream
#include <iomanip> // input-output manipulation

...

std::cout << "sum = " << std::setw(15) << sum << std::endl; 
// ширина поля - 15 символов

// std::setw(15) и подобные ей команды работают 
// только для одной следующей переменной! 
// После вывода sum предыдущие правила вывода будут забыты!

std::cout << "sum = " << std::setw(15) << std::setfill('-') << sum << std::endl; 
// ширина поля - 15 символов, а свободные места заполнить символом '-'

std::cout << std::oct << sum << std::endl; 
// вывод в восьмеричной системе счисления 
```

Подробнее: [здесь](https://en.cppreference.com/w/cpp/header/iomanip)




## const и constexpr (С++11)

`constexpr` позволяет проводить вычисления переменных на этапе компиляции (что не может `const`). Constexpr-переменная является константой, а константа не является constexpr-переменной.

```cpp
// const int a1 = 10; - плохо
constexpr int a1 = 10; // хорошо
```

### constexpr-функции
Тут проще понять на простом примере:

```cpp

int func(int x)
{
    return x < 0 ? -x : x;
}

constexpr int func2(int x)
{
    return x < 0 ? -x : x;
}

int main() {
    constexpr int a1 = func(-4); // Ошибка: функция func - не constexpr-выражение
    int a2 = func(-4); // Вычисление в runtime
    constexpr int a3 = func2(-4); // Вычисление в compiletime
    int a4 = func2(-4); // Вычисление в compiletime
    int b1;
    std::cin >> b1;
    const int res = func(b1); // Вычисление в runtime
}
```

Подробнее смотри [здесь](https://habr.com/ru/articles/228181/)