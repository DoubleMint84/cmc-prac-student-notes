# Семинар №4 - Делегирующие конструкторы, Преобразование чисел в строку, Перегрузка функций

## Делегирующие конструкторы

Пусть у нас есть класс, который хранит вещественное число:

```cpp
class Foo {
public:
    Foo(const double x) : x_{x} {}
private:
    double x_{};
};
```

Вдруг нам захотелось сделать так, чтобы конструктор, принимая на вход вещественное число, делал что-то еще, помимо конструирования объекта. Здесь нам помогут делегирующие конструкторы:

```cpp
class Foo {
public:
    Foo(const double x) : x_{x} {}
    Foo(const int x) : Foo(double(x)) { // Просим конструктор выше создать объект
        // Продолжаем конструирование объекта...
    }
private:
    double x_{};
};
```

Выглядит красиво, не так ли? Заметим, что объект считается созданным после завершения первого конструктора `Foo(double)`! Кроме этого, у делегирования конструкторов есть интересный побочный эффект: в случае, если внутри конструктора, производящего делегирующий вызов первого конструктора `Foo(double)`, произойдет выброс исключения, то для объекта будет вызван деструктор! А значит, утечки памяти не произойдет!

## Преобразование чисел в строку

Любое число, целое или вещественное, мы можем превратить в строку через `std::to_string()`:
```cpp
std::string res = std::to_string(func(x));
```

## Перегрузка функций с одним аргументом

Ранее мы уже знакомились с механизмом перегрузки функций в C++. Ниже мы изучим его поподробнее.

Перегрузка функций:
- это механизм, позволяющий одинаково именовать РАЗНЫЕ функции в пределах одной области видимости.
- проявление статического (полностью разрешаемого на стадии компиляции программы) полиморфизма.

### Пример с одним аргументом
```cpp
#include <iostream>

class Foo {
public:
    Foo() noexcept = default;
    Foo(const int x) noexcept : x_{x} {}
    // Эквивалентно с использованием делегирующих конструкторов:
    // Foo(const int x) noexcept : Foo() { x_ = x; }
private:
    int x_{};
};

std::string func(char x) {
    std::cout << __PRETTY_FUNCTION__  << std::endl;
}

void func(int x) {
    std::cout << __PRETTY_FUNCTION__  << std::endl;
}

void func(long x) {
    std::cout << __PRETTY_FUNCTION__  << std::endl;
}

void func(float x) {
    std::cout << __PRETTY_FUNCTION__  << std::endl;
}

void func(Foo x) {
    std::cout << __PRETTY_FUNCTION__  << std::endl;
}

int main() {
    func(10); // void func(int)

    сhar p = 10;
    func(p); // std::string func(char)

    std::string res = func(x); // std::string func(char)
                            // если x не char, то не скомпилируется!
}
```

### Правила отбора

1. Точное совпадение (exact matching): 
   - int -> int; 
   - typedef, typename - расшифровываются; 
   - const type -> type; 
   - type& -> type, type[] -> type*; 
   - Если не нашлась функция, то переход к следующему правилу
2. Расширение типов (type promotion): 
    - char -> int, (никто к long не приводится, даже int),
    - float -> double, 
     - Если не нашлась функция, то переход к следующему правилу
3. Преобразование типов (type convertion): 
   - int -> char,
   - double -> float, 
   - type* -> void*, 
   - 0 -> type*; 
   - если аргумент имеет тип int, а аргументы функции имеют тип либо char, либо long, компилятор не сможет выбрать из этих двух кандидатов подходящую функцию и завершит компиляцию с ошибкой.
   - Если не нашлась функция, то переход к следующему правилу
4. Пользовательское преобразование (user convertion): 
   - int -> Foo
   - Если не нашлась функция, то переход к следующему правилу
5. Преобразование по эллиптической конструкции `...` (только для функций с переменным числом параметров)

### Глубина пользовательского преобразования
Допускается не более одного пользовательского
преобразования для обработки одного вызова для
одного параметра.

Например:
```cpp
class A { public: A(B b) {...} ...};
class B { public: B(C c) {...} ...};
class C { public: C(int x) {...} ...};


int f2(A a) {
    // ...
}

...

// Казалось бы, int преобразуется в A путем нескольких преобразований
// Однако:
f2(15); // не сработает, потому что
// допускается не более одного пользовательского преобразовнания
```

## Перегрузка функций с двумя и более аргументами

1. Отбираются все функции, которые могут быть вызваны с указанным в вызове количеством параметров
2. Для каждого параметра вызова строится множество функций, оптимально отождествляемых по этому параметру
3. Находится пересечение этих множеств:
   - если это ровно одна функция – она и является искомой,
   - если множество пусто или содержит более одной функции, генерируется сообщение об ошибке.

При работе алгоритма для функций с несколькими параметрами обнаружение неоднозначности не приводит к немедленной остановке алгоритма, неоднозначность может быть снята рассмотрением других параметров функции.

Пример:
```cpp
int func(int x, int y)
{
   std::cout << __PRETTY_FUNCTION__ << std::endl;
}

std::string func(long x)
{
    std::cout << __PRETTY_FUNCTION__ << std::endl;
}

void func(float x, std::string c)
{
    std::cout << __PRETTY_FUNCTION__ << std::endl;
}

int func(Foo x, char c)
{
    std::cout << __PRETTY_FUNCTION__ << std::endl;
}


...

f(15, 'c'); 

// Для первого аргумента подходят функции 1 и 4
// Для второго аргумента подходят функции 1 и 4
// Пересечение содержит более одной функции => Ошибка!

Foo bar;
func(bar, 10);  
// Для первого аргумента подходят функции 1 и 4
// Для второго аргумента подходит функция 4
// Пересечение содержит только одну функцию => ОК
```

## Аргументы по умолчанию

    Аргументы по умолчанию - это то, что питон перенял от плюсов.

Можно задавать значения параметров по умолчанию: если при вызове значение параметра не будет явно задано, то функция будет использовать значение по умолчанию.


```cpp
#include <iostream>

void f1(int x)
{
    std::cout << __PRETTY_FUNCTION__ << std::endl;
}

void f2(int x, int y = 10) // Задан аргумент по умолчанию
{
    std::cout << __PRETTY_FUNCTION__ << std::endl;
}

int main()
{
    f1(100);
    f2(100); // y = 10
    f2(100, 0); // y = 0
}
```

**Важно!** Аргументы по умолчанию ВСЕГДА идут после обязательных!
```cpp
#include <iostream>

void f1(int x)
{
    std::cout << __PRETTY_FUNCTION__ << std::endl;
}

void f2(int x, int y = 10, int z)
{
    std::cout << __PRETTY_FUNCTION__ << std::endl;
}

int main()
{
    f1(100);
    f2(100, 0); //  Куда идет 0? в y или z?
    // Ответ: никуда - такое не скомпилируется)
}
```
### А как будет происходить перегрузка?
```cpp
#include <iostream>

void f1(int x)
{
    std::cout << __PRETTY_FUNCTION__ << std::endl;
}

void f1(int x, int y = 10)
{
    std::cout << __PRETTY_FUNCTION__ << std::endl;
}

int main()
{
    f1(100); // какую функцию вызывать? Непонятно :(
    f1(100, 0); // Компилятор завершится с ошибкой!
}
```