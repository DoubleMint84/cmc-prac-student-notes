# Семинар №8B - Работа с памятью в C++, unique_ptr, make_unique, копирование полиморфных объектов

В С++, по сравнению с Си, довольно много нюансов в работе с памятью.

## Как мы обычно работаем с памятью

Как можно создавать объект класса? Есть множество способов:
```cpp
#include <iostream>
#include <vector>

using std::cout, std::endl;

struct A
{
    int x_{0};
    A(int x = 0) : x_{x} 
    {
        cout << __PRETTY_FUNCTION__ << " " << x_ << endl;
    }
    ~A()
    {
        cout << __PRETTY_FUNCTION__ << " " << x_ << endl;
    }
};

int main()
{
    A a1{10}; // Создание объекта на стеке

    A *p1 = new A{13};  // Создание объекта в куче 
    delete p1;          //(Важно не забыть освободить память вручную!)

    A *p2 = new A[2]{1, 2};   // Массив в куче из двух элементов
    // ... 
    
    A *p3 = new A[1]{3};   // Массив из одного элемента в куче
    // ...

    delete[] p2;        //(Важно не забыть освободить память вручную!)
    // Не забывайте для массивов писать в delete квадратные скобки!
    // Иначе произойдет UB!
    delete[] p3;        //(Важно не забыть освободить память вручную!)

}
```
Что здесь плохо? `p1` и `p3` - указатели, но они указывают на разные типы данных
- `p1` указывает на объект класса `A`,
- `p3` указывает на массив из одного элемента класса `A`

Язык Си эти вещи не различал, ну и C++ это поведение тоже унаследовал! Потенциально у нас может возникнуть проблема, когда мы будем эти указатели использовать!

Когда удаляем скаляр, то очевидно, что деструктор вызывается один раз по тому указателю, переданному в операцию delete.

Когда удаляем массив, то деструктор нужно вызывать для каждого элемента, причем в обратном порядке. Так, система поддержки C++ где-то еще рядом с указателем хранит информацию о том, сколько элементов в массиве. Соответственно, когда вызывается `delete[]`, из служебного поля берется количество элементов в массиве и нужное количество раз вызывается деструктор. (Именно поэтому нельзя вызывать для массива просто `delete`!)

Еще одна проблема, связанная с путаницей указателей на скаляры и массивы: есть еще указатели на производные классы. То есть `A*` может указывать не только на объект класса `A`, но и на любой объект, который является производным классом от `A`:


```cpp
struct A
{
    int x_{0};
    A(int x = 0) : x_{x} 
    {
        cout << __PRETTY_FUNCTION__ << " " << x_ << endl;
    }
    virtual ~A() // virtual - для того, чтобы вызывался правильный деструктор
    {
        cout << __PRETTY_FUNCTION__ << " " << x_ << endl;
    }
};

struct B : A
{
    int y_{1};
    B(int x = 0, int y = 1) : A(x), y_(y)
    {
        cout << __PRETTY_FUNCTION__ << " " << x_ << " " << y_ << endl;
    }
    ~B()
    {
        cout << __PRETTY_FUNCTION__ << " " << x_ << " " << y_ << endl;
    }
};

int main()
{
    A *q1 = new B(1, 2); // Так тоже можно!

    //...

    delete q1;
    // delete[] q1; - это будет совсем плохо...
}
```

```
B::B(int, int) 1 2
virtual B::~B() 1 2
virtual A::~A() 1
```

### Правило полиморфного наследования
    Правило полиморфного наследования: появилась виртуальная функция - в классе нужен виртуальный деструктор!

В итоге мы толком не знаем, что такое `A*`! Помимо типичных проблем с динамической памятью (утечка памяти, double-free) C++ добавляет новые!

### Placement new

Самое типовое использование:

```cpp
int main()
{
    void *vp = ::operator new (sizeof(A) * 2); // Преаллоцированный участок памяти

    auto q2 = new (vp) A{1000}; // Деструктор просто так вызываться здесь тоже не будет!
    auto q3 = new ((void *) ((A*)vp + 1)) A{2000};
    // Для placement new явный деструктор не вызывается.
    // Мы должны сами вызвать деструктор:
    q2->~A();
    q3->~A();

    ::operator delete(vp);
}
```

```
A::A(int) 1000
A::A(int) 2000
virtual A::~A() 1000
virtual A::~A() 2000
```

Для чего это бывает нужно?

К примеру, для реализации вектора, в которой аллоцируется буфер размера большего количества элементов. Потом, когда вызываются push_back или emplace_back, потихонечку в буфер дописываются новые элементы.

Так placement new позволяет нам сами реализовывать какие-то контейнеры. Мы полностью берем на себя управление временем жизни тех объектов, которые мы помещаем к себе.

## А что есть в современном C++?

Одна из главных задач: переложить обязанность отслеживания жизни объектов с программиста либо на компилятор (в идеале), либо на вспомогательные классы, которые будут это как-то отслеживать при выполнении и правильно управлять памятью. Так мы переходим к умным указателям и забываем ~~глупые~~ легаси указатели (в некоторых кругах хардкорных прогеров сишные указатели в плюсах являются моветоном).

В общем, у нас не так много вариантов автоматического отслеживания времени жизни ресурсов:
- Монопольное владение 
- Разделяемое владение

## unique_ptr (монопольное владение)
Есть объект, который полностью владеет областью динамической памяти. Время жизни этой области динамической памяти полностью определяется временем жизни владеющего объекта. Как только вызывается деструктор для владеющего объекта, вызывается и деструктор для динамической памяти. Мы можем этот владеющий объект переностить (копировать не можем!), вызывать функции и передавать им владеющий объект с помощью переноса функции, можем принимать из функци владеющий объект. То есть мы его можем таскать с помощью семантики переноса, но владеющий объект должен быть только один. Для выделенной области в каждый момент времени существует только один владеющий объект.

```cpp
#include <iostream>
#include <memory>

using std::cout, std::endl;

struct A
{
    int x_{0};
    A(int x = 0) : x_{x} 
    {
        cout << __PRETTY_FUNCTION__ << " " << x_ << endl;
    }
    virtual ~A() 
    {
        cout << __PRETTY_FUNCTION__ << " " << x_ << endl;
    }
};

struct B : A
{
    int y_{1};
    B(int x = 0, int y = 1) : A(x), y_(y)
    {
        cout << __PRETTY_FUNCTION__ << " " << x_ << " " << y_ << endl;
    }
    ~B()
    {
        cout << __PRETTY_FUNCTION__ << " " << x_ << " " << y_ << endl;
    }
};

int main()
{
    cout << "START MAIN" << endl;
    std::unique_ptr<A> u1{new A{1}};
    cout << "END MAIN" << endl;
}
```

```
START MAIN
A::A(int) 1
END MAIN
virtual A::~A() 1
```

Как мы видим, деструктор вызвался сам!

Мы не можем копировать ссылку, зато можем ее перемещать:

```cpp
int main()
{
    cout << "START MAIN" << endl;
    std::unique_ptr<A> u1{new A{1}};
    {
        cout << "START BLOCK 1" << endl;
        // auto u2 = u1; - Операции копирования для std::unique_ptr нет!
        // Зато мы можем перемещать:
        auto u2 = std::move(u1);
        cout << "END BLOCK 1" << endl;
    }
    cout << "END MAIN" << endl;
}
```

```
START MAIN
A::A(int) 1
START BLOCK 1
END BLOCK 1
virtual A::~A() 1
END MAIN
```

Обратите внимание: здесь объект уничтожается тогда, когда уничтожается u2!

### unique_ptr в функциях

1. Передача по значению через move

```cpp
void f(std::unique_ptr<A> a)
{
    cout << __PRETTY_FUNCTION__ << endl;
}

int
main()
{
    cout << "START MAIN" << endl;
    std::unique_ptr<A> u1{new A{1}};
    
    f(std::move(u1));

    cout << "END MAIN" << endl;
}
```

```
START MAIN
A::A(int) 1
void f(std::unique_ptr<A>)
virtual A::~A() 1
END MAIN
```

Здесь объект умирает после конца функции f.

2. Передача по ссылке
```cpp
void f(std::unique_ptr<A> &a)
{
    cout << __PRETTY_FUNCTION__ << endl;
}

int
main()
{
    cout << "START MAIN" << endl;
    std::unique_ptr<A> u1{new A{1}};
    
    f(u1);

    cout << "END MAIN" << endl;
}
```
```
START MAIN
A::A(int) 1
void f(std::unique_ptr<A>&)
END MAIN
virtual A::~A() 1
```
А здесь объект не умирает ~~в конце Драйва~~ в конце функции `f`! Он продолжает жить...


Такая семантика очень простая и очень эффективная. То есть мы по сути должны каждый раз передать явным образом владение выделенным динамическим объектом.

### unique_ptr в контейнерах

Да, мы можем использовать unique_ptr в стандартных контейнерах STL.

Пример с вектором:

```cpp
int
main()
{
    cout << "START MAIN" << endl;

    std::vector<std::unique_ptr<A>> v1; 
    
    v1.push_back(std::unique_ptr<A>(new A{1})); // push_back здесь работает...
    // но вариант с emplace_back выглядит компактнее:
    v1.emplace_back(new A{2});
    v1.emplace_back(new A{3});
    
    // В вектор можно класть и существующие объекты (при помощи move):
    std::unique_ptr<A> u(new A{4});
    v1.push_back(std::move(u));

    // С unique_ptr можно работать как с обычным указателем:
    cout << v1[0]->x_ << endl;
    v1[3]->x_ = 666;

    // Как только вектор будет уничтожен, все указатели, хранящиеся в нем, также будут уничтожены

    cout << "END MAIN" << endl;
}
```

```
START MAIN
A::A(int) 1
A::A(int) 2
A::A(int) 3
A::A(int) 4
1
END MAIN
virtual A::~A() 1
virtual A::~A() 2
virtual A::~A() 3
virtual A::~A() 666
```

Как можно заметить, *вектор уничтожает объекты в том же порядке, в котором они создавались.*

### unique_ptr от массива

```cpp
int
main()
{
    cout << "START MAIN" << endl;

    std::unique_ptr<A[]> u{new A[4]{1, 2, 3, 4}};
    
    cout << u[0].x_ << endl;
    u[0].x_ = 0;

    cout << "END MAIN" << endl;
}
```

```
START MAIN
A::A(int) 1
A::A(int) 2
A::A(int) 3
A::A(int) 4
1
END MAIN
virtual A::~A() 4
virtual A::~A() 3
virtual A::~A() 2
virtual A::~A() 0
```

Как было уже сказано выше, *в случае с массивами порядок уничтожения объектов будет инвертирован.*

### unique_ptr с объектами производного класса

Можем ли мы использовать `unique_ptr<A>` с объектами производного класса `B`?  Ответ - можно:
```cpp
int main()
{
    cout << "START MAIN" << endl;
    std::unique_ptr<A> u{new B{1, 2}};
    cout << "END MAIN" << endl;
}
```
```
START MAIN
A::A(int) 1
B::B(int, int) 1 2
END MAIN
virtual B::~B() 1 2
virtual A::~A() 1
```

Деструктор тоже будет вызываться корректно. То есть если в классе есть виртуальный деструктор, то когда у нас заканчивается время жизни `unique_ptr`, то вызывается виртуальный деструктор и память будет корректно освобождена.

`unique_ptr` при помощи шаблонной магии поддерживает присваивание указателя на производный класс указателю на базовый класс (внутри происходит неявный каст).

Вернемся к векторам. Использовать вектор указателей на полиморфные объекты - плохо:

```
std::vector<A*> vv1; // Очень плохо!
```

А с `unique_ptr` - безопасно:

```cpp
std::vector<std::unique_ptr<A>> vv2; // Очень круто!
```

### make_unique

Ранее при использовании `unique_ptr` в качестве аргумента конструктора мы сразу же передавали сырой указатель, который был отдельно сконструирован операцией new. Это не очень безопасно.

Пример:
```cpp
void f2(A *p1, A *p2)
{
    //...
}

int main()
{
    f2(new A{1}, new A{2}); // Что не так с этой функцией?
    // Во-первых, порядок вызова конструкторов здесь не определен (зависит от реализации компилятора)
    // Во-вторых, здесь есть проблема, связанная с исключениями.
    // Допустим, конструктор для A{1} завершился успешно,
    // а вто для A{2} - аварийно с выбросом исключения.
    // Что произойдет дальше?
    // Фрагмент f2 не доработал, так как мы исключением из него вывалились.
    // А указатель на A{1} утёк! Мы его потеряли и нет способа потом понять, что он утёк здесь...
}
```

Теперь заменим указатели на `unique_ptr`:
```cpp
void f2(std::unique_ptr<A> p1, std::unique_ptr<A> p2)
{
    //...
}

int main()
{
    f2(std::unique_ptr<A>{new A{1}}, std::unique_ptr<A>{new A{2}});
    // Может ли произойти здесь утечка памяти?
    // Вряд ли, потому что нас спасает от этого unique_ptr
}
```

Но все равно здесь все-таки есть сырой указатель, который какое-то время существует внутри выражения, что не очень хорошо.

Поэтому лучше использовать специальную функцию `make_unique`:

```cpp
int main()
{
    f2(std::make_unique<A>(1), std::make_unique<A>(2));
    auto u1 = std::make_unique<A>(0); // Еще один способ создать unique_ptr
    std::unique_ptr<A> u2 = std::make_unique<B>(4, 5); // Работа с полиморфными объектами также поддерживается
}
```

В аргументах `make_unique` должны быть указаны все те параметры, с которыми может быть вызван конструктор. 

make_unique аналогичен `emplace_back`, которому передаются параметры по отдельности, а сама функция собирает объект у себя внутри.

## Проблема копирования части объекта
При копировании полиморфных классов может возникнуть проблема: мы можем скопировать по ссылке только ЧАСТЬ ОБЪЕКТА. Как решить эту проблему?

Из правил хорошего тона: `A` - это полиморфный класс, у которого есть виртуальный деструктор и наследование, и мы с ним всегда должны работать по указателю. Поэтому, чтобы не попасть в проблемы копирования части объекта по ссылке, лучше всего запретить копирование.

Давайте запретим в классе `A` конструктор копирования, перемещения и операцию присваивания:

```cpp
struct A
{
    int x_{0};
    A(int x = 0) : x_{x} 
    {
        cout << __PRETTY_FUNCTION__ << " " << x_ << endl;
    }
    virtual ~A() 
    {
        cout << __PRETTY_FUNCTION__ << " " << x_ << endl;
    }
    A(const A&) = delete;
    void operator=(const A&) = delete;
};

```

Вопрос: как нам создать такой же новый объект, как и старый?

Вручную это делать очень и очень плохо.

Решение: реализуем виртуальный метод `clone`. 

```cpp
struct A
{
    // ...
    virtual A* clone()
    {
        return new A(x_);
    }
};

struct B : A
{
    // ...
    B* clone() override
    {
        return new B(x_, y_);
    }
};
```

Избавимся от указателей и перейдем к `unique_ptr`...
```
struct A
{
    // ...
    virtual std::unique_ptr<A> clone()
    {
        return std:make_unique<A>(x_);
    }
};

struct B : A
{
    // ...
    std::unique_ptr<B> clone() override
    {
        return std:make_unique<B>(x_, y_);
    }
};
```
**но это не сработает**, увы.

С указателями это сработало, потому что сработал механизм ковариантного типа возвращения (в случае, когда она возвращает указатель на тип, являющийся производным - это допускается).

Для `unique_ptr` это не работает. Но есть решение:

```cpp
struct A
{
    // ...
    virtual std::unique_ptr<A> clone()
    {
        cout << __PRETTY_FUNCTION__ << " " << x_ << endl;
        return std::make_unique<A>(x_);
    }
};

struct B : A
{
    // ...
    std::unique_ptr<A> clone() override
    {
        cout << __PRETTY_FUNCTION__ << " " << x_ << " " << y_  << endl;
        return std::make_unique<B>(x_, y_);
        // Здесь unique_ptr<B> кастуется в unique_ptr<A>
    }
};
```

Использование:

```cpp
int
main()
{
    cout << "START MAIN" << endl;

    std::unique_ptr<A> u7 = std::make_unique<B>(1, 2);

    auto u8 = u7->clone(); // Клонируем, а не передаем владение.
    
    u7->x_ = 4; // Без проблем обращаемся к полю базового класса

    // u7->y_ = 5; - А вот так сделать не получится!
    // потому что u7 - указатель на объект базового класса A, а не B,
    // что ограничивает нас в использовании полей производных классов.
    // Серьезная проблема...

    cout << "END MAIN" << endl;
}
```
```
START MAIN
A::A(int) 1
B::B(int, int) 1 2
virtual std::unique_ptr<A> B::clone() 1 2
A::A(int) 1
B::B(int, int) 1 2
END MAIN
virtual B::~B() 1 2
virtual A::~A() 1
virtual B::~B() 4 2
virtual A::~A() 4
```
Мы только что реализовали абсолютно безопасное копирование объектов.

Однако здесь у нас возникает проблема с наследованием: в примере выше мы можем обращаться к методам и полям базового класса. А вот использовать методы и поля производного класса мы не сможем! На следующем семинаре мы рассмотрим методы решения этой проблемы.

## Заключение

Монопольное владение - достаточно жесткая модель владения. Чтобы понять это - попробуйте написать хотя бы односвязный список на `unique_ptr`, весело не будет. Еще сложнее написать двухсвязный список, а про дерево так и вообще говорить не стоит.

`unique_ptr` - достаточно ограниченная модель владения, но простая и эффективная. Это просто указатель без каких либо полей. Она хороша тогда, когда мы четко понимаем, что владеть объектом будет только одна сущность. Тогда это все будет работать хорошо. А для более сложных моделей владения нам уже потребуется более сложная обвязка в виде `std::shared_ptr`. *Но это уже совсем другая история...*