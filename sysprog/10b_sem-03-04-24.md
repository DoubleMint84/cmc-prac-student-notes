# Семинар №10b - Исключения

## Теория
Обработка исключений в C++ проводится с помощью ключевых слов `try`, `catch` и `throw`. Операторы программы, при выполнении которых необходимо обеспечить обработку исключений, выделяются в `try-catch`-блок.

При возникновении ошибки внутри `try`-блока (возможно, в вызываемых из `try`-блока функциях), то соответствующее исключение должно генерироваться с помощью оператора `throw`, а перехватываться и обрабатываться в теле одного из обработчиков `catch` (расположены после `try`-блока).

Само исключение является объектом некоторого типа. Оно может быть объектом `int`, `char`, `std::string`, пользовательским типом ... чем угодно!

Операторы, которые находятся после места генерации ошибки в `try`-блоке, игнорируются, а после обработки исключения управление передается первому оператору, находящемуся за обработчиками исключений. Отметим, что `try-catch`-блоки могут быть вложенными.

Структура:
```cpp
try
{
    operator 1;
    operator 2;
    ....

    throw exception;
}
catch (type) // Значение исключения не используется, важен только тип
{
    operator a;
    ...
    // throw;
}
catch (type e) // Значение исключения используется внутри catch-блока
{
    operator b;
    ...
    // throw;
}
catch (...) // Обработчик по-умолчанию
{
    operator c;
    ...
    // throw;
}
```

### stdexcept
В специальном заголовочном файле стандартной библиотеки stdexcept объявлены некоторые исключения, которые в общем случае выбрасываются стандартными функциями стандартной библиотеки. Они же доступны нам для использования.

В данном файле предлагается некоторая иерархия наследования исключения. В этой иерархии две ветви наследования: logic_error и runtime_error. 

- logic_error предназначены для использования в тех ситуациях, когда функция или класс накладывает некоторые ограничения контракта, которые нарушаются при их использовании. Это ошибка у того, кто вызывает данную функцию. Пример: функция извлечения квадратного корня принимает значение >= 0.
- runtime_error это ошибки, которые возникают тогда, когда что-т идет не так внутри самой функции. Здесь, в отличие от исключений логического типа, объемлющие данную функцию функции (простите за тавтологию) не обязаны заранее предпринять какие-то действия. Пример: переполнение в арифметической операции. 

    
    Можно создавать свои исключения на базе стандартных. Главное - придерживаться той же логике разделения ошибок на логические и рантайм.


Все эти исключения практически одинаковые. У них всех есть конструктор от std::string (строка, в которой формально описывается, что именно пошло не так). Кроме того, у базового класса `std::exception` есть метод `what`, который и возвращает данную строку.

### В чем отличие от стандартных кодов ошибок?
В отличие от статических конструкций периода компиляции вызовов и возвратов, исключения имеют гораздо более непредсказуемую и динамическую природу. То, где и как будет обрабатываться исключение, зависит от текущего состояния стека вызовов, который совершенно непредсказуем при компиляции программы. Причем во время работы программы, даже в точке вызова одной и той же функции, мы можем иметь совершенно разные стеки вызовов. Обработка исключений существенно использует механизм стека и механизм динамических вызовов функций.

Поэтому вообще говоря для работы исключений потребуется полная поддержка стековых фреймов, и программа, в которой используются исключения, может нескомпилироваться, если мы не используем frame-pointer'ы.

Поэтому крайне рекомендуется при компиляции добавить флаг:
```
-fno-rtti
```

## Пример работы с исключениями

Простой пример работы с исключениями:
```cpp
#include <stdexcept>
#include <iostream>

using std::cin, std::cout, std::endl;

void g(int x)
{
    if (x == 1) throw 1; // Исключение типа int
    if (x == 2) throw 2L; // исключение типа long
    if (x == 3) throw 'c'; // исключение типа char
    if (x == 4) throw (unsigned char) 10; // исключение типа unsigned char
    if (x == 5) throw std::out_of_range("x is equal to 5"); // исключение типа std::out_of_range
}

void f(int x)
{
    if (x > 0) {
        g(x); // В этой функции возможно возникнет исключение...
    }
}

int main()
{
    int x;

    cin >> x;
    try
    {
        f(x);
    }
    catch (int z) // Ловим исключение типа int из функции g
    {
        cout << "caught int" << endl;
    }
    // А другие типы мы не ловим...
}
```

Если мы напишем 1, то исключение поймается обработчиком:
```shell
> ./main
1
caught int
```

Если мы напишем 2, то исключение не будет поймано подходящим обработчиком для int:
```shell
> ./main
2
libc++abi: terminating with uncaught exception of type long
[1]    66820 abort      ./main
```

Да, вы правильно поняли! `catch(int)` не поймает `long`! В обработчиках исключения не работают никакие стандартные преобразования между интами, integer-promotion, ... все это не работает! Пользовательские преобразования тоже не работают. То есть тип должен быть ровно таким же.

Исключение не будет поймано подходящим обработчиком (его нет), поэтому программа сразу же завершится с ошибкой.

То же самое и для `char`:
```cpp
> ./main
3
libc++abi: terminating with uncaught exception of type char
[1]    66829 abort      ./main
> ./main
4
libc++abi: terminating with uncaught exception of type unsigned char
[1]    66835 abort      ./main
```

Для 5 заметьте, что выводится переданная исключению строка "x is equal to 5":
```shell
> ./main
5
libc++abi: terminating with uncaught exception of type std::out_of_range: x is equal to 5
[1]    64738 abort      ./main
```
`out_of_range` нигде в динамической цепочке вызовов не обрабатывается, поэтому мы вываливаемся из функции `main` с необработанным исключением, после чего в runtime-библиотеке в финальном обработчкие исключений вызывается функция `terminate`. `terminate`, в свою очередь, функцию `abort`. Этого лучше избегать, поэтому...

### `std::set_terminate`
Мы можем изменить функцию-`terminate` по умолчанию через `std::set_terminate`:

```cpp
// Пишем свою функцию-обработчик
void handler(void)
{
    exit(69); // Ничего не выводим, просто завершаем работу через exit
    // В обработчике можно делать что угодно
}

int main()
{
    std::set_terminate(handler); // передаем указатель на функцию-обработчик
    // Понятное дело, что set_terminate нужно прописывать как можно раньше

    // ...
}
```
После этого вывод для 5 поменяется (через `echo` узнаем код ошибки):
```shell
> ./main
5
> echo $?
69
```

## Как происходит перехват исключений
Для каждого `try`-блока может быть несколько операторов `catch`. При поиске обработчика они просматриваются по очереди сверху вниз. От типа сгенерированного исключения зависит, какой именно обработчик `catch` будет использован.

Выбираться будет первый обработчик с типом параметра, совпадающим с типом исключения.

В случае абстрактных классов нужно отметить, что обработчики с базовым типом (или с указателем/ссылкой на объект базового типа) перехватывают все исключения с производным типом (или его адресом). Для корректной работы следует располагать обработчики с производными типами выше обработчиков с базовыми типами.

Аргумент обработчика получает значение исключения при его перехвате данным обработчиком. Это значение можно использовать в теле обработчика. Если значение самого исключения не используется в внутри обработчика, то можно в аргументе указывать только его тип.

Обработчик `catch(...) {}` будет перехватывать любые исключения. Он должен распологаться в конце последовательности обработчиков `catch`.

Если для сгенерированного исключения в текущем `try`-блоке нет подходящего обработчика, оно перехватывается объемлющим `try`-блоком. В пример выше: `main() -> f() -> g()`.

Как было написано выше, если подходящий обработчик не удалось найти, может произойти ненормальное завершение программы.

## Две стадии обработки исключений
1. Используется динамический стек вызовов для того, чтобы найти то место в программе, где будет обрабатываться исключение соответствующего типа. То есть при выполнении `throw` будет вызвана библиотечная функция `__cxa_throw`, которая просмотрит стек от точки, в которой было вызвано исключение, до функции `main`, и поищет в них обработчки исключений. При этому никакой свертки стека еще выполняться не будет. 
2. Если обработчик не найден, то тогда сама функция `__cxa_throw` будет вызывать `std::terminate`, который вызовет `abort`. В результате `abort` вызывает сигнал. При этом у нас сохраняется вся динамическая цепочка вызовов от функции `main` (что при дебаггинге очень удобно для просмотра бэктрейса).
3. Если функция `__cxa_throw` нашла где-то выше в стеке вызовов точку, в которой исключение обрабатывается, то только тогда произойдет свертка стека. По очереди будут браться стековые фреймы, и для каждого такого фрейма будут вызываться деструкторы тех объектов, которые размещены на этих стековых фреймах.

## Вернемся к нашему примеру

### Ссылки в аргументе обработчика
Мы можем указывать ссылку в аргументе обработчика:

```cpp
int main()
{
    int x;

    cin >> x;
    try
    {
        f(x);
    }
    catch (int &z) // Ловим исключение типа int из функции g
    { // Для 1 поймается
        cout << "caught int" << endl;
    }
}
```

и константную ссылку тоже:

```cpp
int main()
{
    int x;

    cin >> x;
    try
    {
        f(x);
    }
    catch (const int &z) // Ловим исключение типа int из функции g
    { // Для 1 ТОЖЕ поймается
        cout << "caught int" << endl;
    }
}
```

### `catch(...)`
Чтобы не вываливаться в объемлющий `try`-`catch`-блок, можно добавить последним обработчик `catch(...)`:

```cpp

int main()
{
    int x;

    cin >> x;
    try
    {
        f(x);
    }
    catch (const int &z) 
    { 
        cout << "caught int" << endl;
    }
    catch (...) // Исключение в качестве параметра доступно не будет.
    {
        // Например:
        abort();
    }
}
```

```
> ./main
3
[1]    67265 abort      ./main
```

Обратите внимание, в данном случае к моменту вызова `abort` в обработчике наш стек вызовов был свернут. И поэтому так делать не надо, потому что обработчик, поймав любое исключение, скрывает истинную причину исключения и уничтожает состояние, которые привели к исключению. И, в итоге, по бэктрейсу при деббагинге мы не сможем понять, что именно вызвало исключение. Лучше программа упадет по необработанному исключению, нежели никогда не будет падать.

### Заворачиваем всю функцию main в try-catch-блок

Да! Вы все правильно поняли:

```cpp
int main() try
{
    int x;

    cin >> x;
    try
    {
        f(x);
    }
    catch (const int &z) 
    { 
        cout << "caught int" << endl;
    }
}
catch(...)
{
    std::cerr << "!!!" << std::endl;
}
```

```
> ./main
3
!!!
```

**Даже не смейте писать этот трэш...**

Можно считать, что стандартная библиотека вызывает `std::terminate` следующим образом:

```cpp
int main() try
{
    int x;

    cin >> x;
    try
    {
        f(x);
    }
    catch (const int &z) 
    { 
        cout << "caught int" << endl;
    }
}
catch(...)
{
    std::terminate();
}
```

Все равно так делать НЕ НАДО!

## Про объекты исключений и их жизненный цикл
Давайте выясним более точно, что происходит в момент выброса исключения и его ловли. 

### Простейший случай

Создадим наш собственный класс исключений (наследуемся от `std::exception`):
```cpp
#include <iostream>
#include <stdexcept>

using std::cout, std::cin, std::endl;

struct MyException : std::exception
{
    MyException() : std::exception()
    {
        cout << __PRETTY_FUNCTION__ << endl;
    }
    ~MyException()
    {
        cout << __PRETTY_FUNCTION__ << endl;
    }
    // Не забываем: если мы используем наследование, то по умолчанию
    // конструктор копирования базового класса не вызывается.
    // Поэтому важно не забыть вызвать самостоятельно
    // конструктор копирования базового класса.
    MyException(const MyException &other) : std::exception(other)
    {
        cout << __PRETTY_FUNCTION__ << endl;
    }
    // То же самое и с конструктором переноса
    MyException(MyException &&other) : std::exception(other)
    {
        cout << __PRETTY_FUNCTION__ << endl;
    }
};
```

Напишем простую программу:
```cpp
void f(int x)
{
    if (x < 0) throw MyException(); 
    // Здесь создается новый объект класса MyException.
}

int main()
{
    int x; 
    cin >> x;
    try {
        f(x);
    } catch (MyException x) {
        cout << "exception" << endl;
    }
}
```

Запустим её:
```
> ./main
-3
MyException::MyException() - создаем объект в области памяти исключений
MyException::MyException(const MyException &) - копируем по значению объект в catch
exception
virtual MyException::~MyException() - уничтожаем объект в catch
virtual MyException::~MyException() - уничтожаем объект в области памяти для исключений
```

В функции `f` в `throw` создается новый объект класса `MyException` и он размещается в некоторой области памяти, специально выделенной для хранения объектов исключений. Эта область памяти отдельная от Глобальных и Локальных переменных, и в ней память выделяется через специальную функцию `__cxa_allocate_exception`.

Если бы мы передавали в `throw` уже существующий объект:
```cpp
void f(int x)
{
    MyException z;
    if (x < 0) throw z; 
}
```

```
> ./main
-1
MyException::MyException() - создаем объект z внутри функции f
MyException::MyException(MyException &&) - "переносим" объект в область памяти для исключений
virtual MyException::~MyException() - уничтожаем объект z в конце f
MyException::MyException(const MyException &) - копируем по значению объект в catch
exception
virtual MyException::~MyException() - уничтожаем объект в catch
virtual MyException::~MyException() - уничтожаем объект в области памяти для исключений
```
То здесь у нас вызывается конструктор переноса, размещающий объект в области объектов исключений. (если бы, кстати, мы бы не определили конструктор переноса, то вместо него вызывался бы просто конструктор копирования).

Когда умирает объект исключения в области памяти для исключений? В примере выше объект умирает в конце ~~Драйва~~ блока обработки исключения `catch`. Однако, если бы мы в обработчике написали `throw` без аргумента:

```cpp
    try {
        f(x);
    } catch (MyException x) {
        cout << "exception" << endl;
        throw;
    }
```

Здесь объект исключения продолжит жить и исключение будет перевыброшено дальше. Мы продолжим искать обработчик нашего исключения.

А если бы мы в `catch` использовали аргумент по ссылке?

```cpp
    try {
        f(x);
    } catch (const MyException &x) {
        cout << "exception" << endl;
    }
```

```
> ./main
-1
MyException::MyException() - создаем объект z внутри функции f
MyException::MyException(MyException &&) - "переносим" объект в область памяти для исключений
virtual MyException::~MyException() - уничтожаем объект z в конце f
exception
virtual MyException::~MyException() - уничтожаем объект в области памяти для исключений
```

Здесь мы избавились от лишнего копирования.

Давайте для еще большей минимизации копирований в самой функции f будет создавать объект внутри `throw`:

```cpp
void f(int x)
{
    if (x < 0) throw MyException();
}

int main()
{
    int x; 
    cin >> x;
    try {
        f(x);
    } catch (const MyException &x) {
        cout << "exception" << endl;
    }
}
```

```
> ./main
-1
MyException::MyException() - создаем объект в области памяти исключений
exception
virtual MyException::~MyException() - уничтожаем объект в области памяти для исключений
```

Стало еще лучше!

Вывод: **в catch лучше принимать аргумент не по значению, а по ссылке!** Это существенно уменьшает количество операций копирования.

### Вложенные `try-catch`-блоки
Для наглядности расширим возможности нашего класса:
```cpp
struct MyException : std::exception
{
    int val{};
    MyException(int val = 0) : std::exception(), val(val)
    {
        cout << __PRETTY_FUNCTION__ << " " << val << endl;
    }
    ~MyException()
    {
        cout << __PRETTY_FUNCTION__ << " " << val << endl;
    }
    MyException(const MyException &other) : std::exception(other)
    {
        cout << __PRETTY_FUNCTION__ << " " << val << endl;
    }
    MyException(MyException &&other) : std::exception(other)
    {
        cout << __PRETTY_FUNCTION__ << " " << val << endl;
    }
};

void f(int x)
{
    if (x < 0) throw MyException(100);
}
```

И посмотрим, что будет происходить в случае, если:

- `throw` без аргумента

```cpp
int main()
{
    int x; 
    cin >> x;
    try {
        try {
            f(x);
        } catch (const MyException &x) {
            cout << "exception " << x.val << endl;
            throw;
        }
    } catch (MyException &y) {
        cout << "exception " << y.val << endl;
    }
}
```

```
> ./main
-1
MyException::MyException(int) 100 - создаем объект в области памяти исключений
exception 100 - поймали исключение во вложенном блоке
exception 100 - поймали исключение в наружном блоке
virtual MyException::~MyException() 100 - в конце наружного блока catch уничтожаем объект исключения в области памяти исключений
```

- `throw` с аргументом
```cpp


int main()
{
    int x; 
    cin >> x;
    try {
        try {
            f(x);
        } catch (const MyException &x) {
            cout << "exception " << x.val << endl;
            throw MyException(200);
        }
    } catch (MyException &y) {
        cout << "exception " << y.val << endl;
    }
}
```

```
> ./main
-1
MyException::MyException(int) 100 - создаем объект в области памяти исключений
exception 100 - поймали исключение во вложенном блоке
MyException::MyException(int) 200 - создаем новый объект в области памяти исключений
virtual MyException::~MyException() 100 - в конце вложенного блока catch уничтожаем старый объект исключения в области памяти исключений
exception 200 - поймали исключение в наружном блоке
virtual MyException::~MyException() 200 - в конце наружного блока catch уничтожаем объект исключения в области памяти исключений
```

## Исключения + Наследование = ???
Как уже ранее говорилось, никогда не распологайте обработчики базовых типов выше обработчиков производных типов:
```cpp
int main()
{
    int x; 
    cin >> x;
    try {
        f(x);
    } catch (const std::exception &x) {
        cout << "base" << endl;
    } catch (const MyException &x) {
        cout << "exception " << x.val << endl;
    }
}
```

В данном случае компилятор поругается на вас:

```shell
> make
g++ -g -Wall  -std=gnu++20 -D_GNU_SOURCE    main.cpp   -o main
main.cpp:47:23: warning: exception of type 'const MyException &' will be caught by earlier handler [-Wexceptions]
        }catch (const MyException &x) {
                      ^
main.cpp:44:24: note: for type 'const std::exception &'
        } catch (const std::exception &x) {
                       ^
1 warning generated.
```

```
> ./main
-1
MyException::MyException(int) 100
base
virtual MyException::~MyException() 100
```

Здесь мы НИКОГДА не попадем в обработчик производного типа, поэтому так писать не стоит!

Правильно:

```cpp
int main()
{
    int x; 
    cin >> x;
    try {
        f(x);
    } catch (const MyException &x) {
        cout << "exception " << x.val << endl;
    } catch (const std::exception &x) {
        cout << "base" << endl;
    }
}
```
```
> ./main
-1
MyException::MyException(int) 100
exception 100
virtual MyException::~MyException() 100
```

Кроме того, если мы будем брать для типа базового класса аргумент по значению, а не по ссылке, то при копировании у нас произойдет срезка объекта! Об этом тоже нужно помнить: при возникновении иерархии никогда не используем передачу по значению!

## Исключения, генерируемые в функциях

### Вредный совет (возможно deprecated)
В заголовке функции можно указать типы исключений (через запятую), которые может генерировать функция (эту возможность удобно использовать при описании библиотечных функций):

```cpp
result_type func_name(arguments...) [const] throw (список_типов) { ... }
```

Если список типов пустой, то функция не может генерировать никаких исключений.

Если же функция все-таки сгенерировала недекларированное исключение, вызывается библиотечная функция `unexpected()` работающая аналогично функции `terminate()`.

Использование аппарата исключений - единственный безопасный способ нейтрализовать ошибки в конструкторах и деструкторах, поскольку они не возвращают никакого значения, и нет другой возможности отследить результат их работы.

Если деструктор, вызванный во время свертки стека, попытается завершить свою работу при помощи исключения, то система вызовет функцию `terminate()`, что крайне нежелательно. Отсюда важное требование к деструктору: ни одно из исключений, которое могло бы появиться в процессе работы деструктора, не должно покинуть его пределы.

### Полезный совет
В настоящее время строгая типизация исключений для функций считается скорее неудобной чем хорошей. Лучше ничего не специфицировать, если ваша функция может выбросить исключение.

Кроме того, это неудобно в наследовании: если в базовом классе какой-то метод выбрасывает только определенные исключения, то в производных классах мы не можем выбрасывать другие исключения, потому что в контракт заспецифицирован в базовом классе.

А если ваша функция не выбрасывает исключений вообще, то лучше это зафиксировать через `noexcept`:

```cpp
result_type func_name(arguments...) [const] noexcept { ... }
```

Это очень полезно для заголовочных файлов: при компиляции вызовов функции, которые никогда не выбрасывают исключения, компилятор может выполнять оптимизации, которые невозможны в случае, когда функция выбрасывает исключение.

Поэтому мы и писали `noexcept` в конструкторах классов.

## Минусы исключений
Исключения C++ могут приводить к достаточно некрасивому коду.

Стандартная задача: проверить, что функция конвертирует строку в число.

```cpp
int main()
{
    long val = std::stol(std::string("10", nullptr));
}
```

Здесь странно и неудобно, что функция std::stol выбрасывает исключение, потому что это приводит к достаточно некрасивыми конструкциям.

```cpp
int main()
{
    long val; // Нужно заранее определять переменную...
    try {
        val = std::stol(std::string("10", nullptr));
    }
    catch (...) {
        //Ставим дефолтное значение для val
    }
}
```

А мы всего лишь хотели из строки получить число...

## Интересный факт

Многие корпорации придерживаются политики "Мы не используем исключения в C++". Пример: style-гайд для C++ от гугла. В Яндексе же исключения используются, но в меру.

Почему? По историческим причинам на разных ОС исключения обрабатывались с некоторыми нюансами по-разному. К примеру, для Windows 32-bit исключения приводили к достаточно существенному penalty при исполнении программ. Обработка исключения может накладывать достаточно существенный накладной расход даже в случае, когда исключения никогда не вызываются. 

В современных Windows 64-bit и Unix-системах исключения с точки зрения времени выполнения бесплатны, если вы их не используете. Но сами исключения являются довольно сложным механизмом. Они медленные и не очень эффективны. Во многих ситуациях лучше использовать возвращаемое значение для обнаружения ошибок вместо исключений.

Пример: в функции открытия файла что лучше использовать в качестве признака file_not_found: исключения или код ошибки? В данном случае лучше использовать второй вариант, потому что отсутствие файла - совершенно нормальная штатная ситуация. Нет ничего необычного в том, что файл отсутствует в файловой системе. Ну и соответственно обрабатывать эту ситуацию нужно штатно без выброса исключений.

Исключения были в моде в 70-x - 90-x годах прошлого века. В языках C++, Java, C# в большей или меньшей степени активно используются исключения. Но в языках-зумерах (Go, Rust) исключения не используются, потому что люди нашли более оптимальные варианты обработки ошибок в функциях. Обычно функция с обработкой ошибок в зумерском стиле возвращает пару значений: код ошибки (или ее отсутствия) и само нормальное возвращаемое значение.

Пример на C++
```cpp
std::pair<bool, int> add(int x, int y)
{
    int res;
    if (__builtin_add_overflow(x, y, &res)) {
        return {false, res};
    } else {
        return {true, res};
    }
}

int main()
{
    auto [success, value] = add(x, y);
    // Здесь мы должны сами проверять успешность функции
    // В каком-то роде это C-style, но зато эффективно!
}
```

Современные языки Rust и Go требуют от нас, чтобы флаг ошибки был проверен и ошибка была обработана. В C++ тоже могут потребовать проверку возвращаемого значения с помощью соответствующих аннотаций или флагов компиляции.

----
При написании данного конспекта использовалось [видео с семинара 2020 года А. В. Чернова и А. А. Шестимерова](https://youtu.be/PLFZUT2ijqI?feature=shared) 
