# Семинар №5

## Переопределение операторов (арифметических в том числе)
Зачем: чтобы программа консистентно выглядела (например: при реализации операций алгебры).
На [cppreference](https://en.cppreference.com/w/cpp/language/operators) есть список (с пояснениями) операторов, которые мы можем переопределять.

Какие операторы НЕЛЬЗЯ переопределить:

- `::`
- `typedef`
- `.`
- `.*`
- `?:`


Все остальные (за некоторыми исключениями) - МОЖНО!

### Виды операторов:
- Инфиксные (infix operators) - в середине выражения (слева и справа по операнду): `+`, `-`, `/`, `*`, `%`, `=`, `<`, `>`, `+=`, `-=`, `<<`, `>>`, `<<=`, `>>=`, `!=`

- Префиксные (prefix operators) - справа операнд (только один): `++`, `--`, `!`, `&`, `-`, `+` (да, писать `+var` можно!), `.`, `*:`, `.x` (обращение к полю)
- Постфиксные (postfix operators) - слева операнд (только один): `++`, `--`
- Special: `->`, `->*`, `[]` (причем в C++23 (!) у них расширился функционал), `()` (причем в плюсах у них расширился функционал)

## Как переопределять операторы

### Инфиксные операторы

Простейший пример с оператором сложения и вычитания.
```cpp
class MyInt
{
    int x_{};
public:
    MyInt() = default;
    MyInt(int x) : x_{x} {}
    int x() const { return x_; }

    // Можно переопределить оператор внутри класса:
    MyInt operator+(const MyInt b) const 
    // Указываем ОДИН аргумент, потому что:
    // - первый операнд - сам экземпляр класса!
    // - второй операнд - аргумент b
    // const - операция не меняет состояние объекта
    {
        return MyInt(x_ + b.x()); // Не очень хорошее решение, но пойдет
    }
};

// Можно определять операции как свободные функции.
// Рассмотрим на примере вычитания:
MyInt operator-(const MyInt a, const MyInt b) // Теперь ДВА аргумента!
{
    return MyInt(a.x() - b.x());
}

int main()
{
    MyInt a1(10);
    MyInt b1(20);
    MyInt c1 = a1 + b1;  // Эквивалентно с1(30);
}
```

Единственное, что смущает - это обязательное использование геттера для аргумента. К счастью, в плюсах есть друзья класса!

#### Ключевое слово friend

Другу класса становятся доступны `private` поля (но не `protected`!)

Тогда без геттеров реализация оператора выглядит так:
```cpp
class MyInt
{
    ...
    friend MyInt operator-(const MyInt a, const MyInt b) const 

};

MyInt operator-(const MyInt a, const MyInt b)
{
    return MyInt(a.x_ - b.x_); // Без геттера!
}

```

#### Важный момент
Для минимизации ошибок пытайтесь писать код так, чтобы свойство ассоциативности выполнялось:
```
a + b + c  ~  (a + b) + c
a = b = c  ~  a = (b = c)
a + b * c  ~  a + (b * c)
```
#### Пример с присваиванием
```cpp
class MyInt 
{
    ...

    MyInt& operator += (MyInt b)
    {   // состояние объекта меняется!
        // амперсант в начале - копирования не происходит! 
        // Объект передается по ссылке
        x_ += b.x();
        return *this;
    }
    // Данный метод не очень корректен, об этом расскажу ниже
};

int main()
{
    MyInt a1(10);
    MyInt b1(20);
    a1 += b1; // Результат: a.x_ = 30
}
```

#### Не очень хороший код с присваиванием

Для целочисленных переменных есть не очень хороший пример присваивания:

```cpp
int a2 = 10, b2 = 20, c2 = 30;
a2 += b2 += c2;
std::cout << "a2 =  " << a2 << "; b2 = " << b2 << "; c2 = " << c2 << std::endl
```

```
Результат:
a2 = 60; b2 = 50; c2 = 30
```

Согласитесь, это выглядит не очень очевидно.

Рассмотрим очень сомнительный пример теперь для нашего класса:
```cpp
MyInt a1(10);
MyInt b1(20);
MyInt c1(30);

(a1 += b1) += c1;
std::cout << a1.x() << std::endl; // Что выведет код сверху?

// Ответ: 60
```
Вообще говоря, такой код не очень корректен.

Поэтому для префиксных операторов, меняющих состояние, принято возвращать константную ссылку:

```cpp
class MyType {
    const MyInt& operator += (const MyInt b)
    {
        x_ += b.x();
        return *this;
    }

    const MyInt& operator -=(const MyInt b)
    {
        x_ -= b.x();
        return *this;
    }
};

int main() {
    ... 
    (a1 += b1) += c1; // Не скомпилируется!!
}
```

    Если ваше чувство вкуса претит вам такое писать, 
        то лучше писать const!


#### Необычная реализация оператора через оператор присваивания

Можно сначала реализовать оператор присваивания c делением, а потом реализовать оператор инфиксного деления с использованием описанного выше оператора:

```cpp
class MyInt{
    ...
    const MyInt& operator /=(const MyInt b)
    {
        x_ /= b.x();
        return *this;
    }
}

...

MyInt operator / (MyInt a, const MyInt b)
{
    a /= b;
    return a;
}
```

#### Почему лучше использовать свободные функции для инфиксных операторов?
Как мы уже знаем, для инфиксных операторов, описанных в классе, первый операнд передается через this, второй - через аргумент. А для свободных функций оба операнда передаются через аргументы. С этим связаны некоторые тонкости...

Пусть мы описали сложение в классе, а вычитание - через свободную функцию:

```cpp
class MyInt {
    ...
public:  
    MyInt(int x) : x_{x} {} // Конструктор преобразования!

    MyInt operator+(const MyInt b) const
    {
        return MyInt(x_ + b.x());
    }

    friend MyInt operator-(const MyInt a, const MyInt b);

};

MyInt
operator-(MyInt a, MyInt b)
{
    return MyInt(a.x_ - b.x_);
}
```


Тогда если оба операнда явно имеют тип MyInt, то все будет работать корректно в обоих случаях:
```cpp
int main() {
    
    ... 

    auto c3 = a1 + b1;
    auto d3 = a1 - b1;
}
```

А если один операнд будет иметь тип int?

```cpp
int main() {
    ...

    auto e3 = a1 + 10; // Сработает, потому что 10 скастится в MyInt(10)!
    auto f3 = 10 + a1; // ОШИБКА! 
    // int не имеет подходящего перегруженного оператора для сложения с MyInt!
    auto g3 = 10 - a1; // Сработает, 
    // потому что В СВОБОДНОЙ ФУНКЦИИ 10 скастится в MyInt(10)! 
}
```

Важный **Довод**: 
    
    объявлять инфиксные операторы через свободные функции!



### Префиксный оператор
Описание префиксного оператора внутри класса производится аналогично инфиксным операторам.

Рассмотрим на примере оператора "унарный минус":
```cpp
class MyInt {
    ...

    MyInt operator -() const
    {
        return MyInt(-x_);
    }
};

```

Если вам вздумалось сделать так, чтобы унарный минус менял состояние объекта, то никто вам не запрещает так делать (но лучше воздержаться от этого):

```cpp
class MyInt {
    ...

    MyInt& operator -() 
    {
        x_ = -x_;
        return *this;
    }
}
```

Кстати говоря, существует "крайне полезная" операция унарного плюса!

```cpp
class MyInt {
    friend MyInt operator + (MyInt a)
    {
        return a;
    }
}
```

#### Как отличить префиксный оператор от постфиксного?

Рассмотрим на примере префиксного и постфиксного инкрементов:
```cpp
class MyInt {
    // ПРЕФИКСНЫЙ ОПЕРАТОР (в friend вообще нет необходимости!)
    const MyInt& operator++()
    {
        ++x_;
        return *this;
    }

    // ПОСТФИКСНЫЙ ОПЕРАТОР (реализует побочный эффект)
    MyInt operator++(int fix)   // Оператор отличает префиксный и постфиксный
    {                           // операторы по ФИКТИВНОМУ ПАРАМЕТРУ!
        MyInt tmp = *this;
        ++x_;
        return tmp;
    }
};
```

### Сравнения

Реализуются вполне очевидно:
```cpp
class MyInt {
    ...

    friend bool operator < (MyInt a, MyInt b)
    {
        return a.x_ < b.x_;
    }
    friend bool operator == (MyInt a, MyInt b)
    {
        return !(a < b) && !(b < a);
    }
    friend bool operator <= (MyInt a, MyInt b)
    {
        return (a < b) || (a == b);
    }
};
```

Минус: Куча boilerplate :(

    boilerplate - куча строк бессмысленного кода с нулем логики, без которого ничего работать не будет. Злоупотребляют этим Microsoft (WinAPI, ранние версии DirectX) и Qt.

К счастью, со стандарта C++20 появился новый оператор сравнения!

#### (C++20) Оператор трехстороннего сравнения

Новый стандарт вводит следующие разновидности сравнения:

|             |Равенство| Упорядочение |
|-------------|---------|--------------|
| Базовые     |  `==`   |  `<=>`       |
| Производные |    `!=` |`<, <=, >, >=`|

Основное отличие **базовых** операторов сравнения от производных - со стандарта C++20 операнды базовых операторов могут быть обращены!

То есть:

```cpp
class MyInt {
    ...

    bool operator==(int b) const { 
        return x_ == b;
    }
};


int main() {
    MyInt a1(10);

    a1 == 10; // Корректно в C++17 и C++20
    10 == a1; // Ошибка в C++17, корректно в C++20
    // Заметьте, что компилятор не создает новых функций! 
    // Он просто меняет операнды местами.
}
```

А с производными операторами сравнения такой "финт ушами" совершить нельзя!
Таким образом, можно сделать вывод, что:

    В типе нужно описывать ТОЛЬКО базовые операторы == и <=>!

#### Пример использования оператора `<=>`
```cpp 
class MyInt {
    ... 
    friend std::strong_ordering operator <=> (MyInt a, MyInt b) = default;
};
```

Он сразу сравнивает ВСЁ! Рассматривает классы как множества!

#### Категории сравнения
С новым стандартом были введены три категории сравнения (в скобках примеры):
- strong ordering (int) - отношение линейного порядка + взаимозаменяемость операндов. 
  - `strong_ordering::equal`, `strong_ordering::less`, `strong_ordering::greater`
- weak ordering (нечувствительное к регистру сравнение строк) - некоторый класс эквивалентности
  - `weak_ordering::equivalent`, `weak_ordering::less`, `weak_ordering::greater`
- partial ordering (float, потому что есть NaN) - отношения частичного порядка
  - `partial_ordering::equivalent`, `partial_ordering::less`, `partial_ordering::greater`, `partial_ordering::unordered`

[Ссылка на подробную статью про сравнения на хабре.](https://habr.com/ru/companies/pvs-studio/articles/465575/)

#### Опишем свое правило упорядочивания
```cpp

class MyInt {
    ... 
    friend std::strong_ordering operator <=> (MyInt a, MyInt b){
        if (a.x_ <= b.x_) {
            return std::strong_ordering::greater;
        }
        else return std::strong_ordering::equal;
    }
    
};
```

### Оператор "круглые скобки"

Грубое определение: Превращает имя объекта в функцию (?!)

Данный оператор можно определить **только** как метод класса:
```cpp
class MyInt {
    ... 
    MyInt operator()(int shift)
    {
        return MyInt(x_ * shift)
    }
};

int main() {
    ... 
    auto e4 = a1(10);
}
```

У оператора могут быть несколько аргументов:
```cpp
class MyInt {
    ... 
    bool operator()(int x, int y)
    {
        return x_ > x && x_ < y;
    }
};

int main() {
    ... 
    auto f4 = a1(10, 10);
}
```

### Оператор "квадратные скобки"
Грубое определение: Превращает имя объекта в массив, к которому можно обращаться через `[]` (?!)
```cpp
class MyInt {
    std::vector<int> vec_{};

public:

    MyInt()
    {
        vec_ = {1, 2, 3};
    } 
    int& operator[](const int index)
    {
        return vec_[index];
    }
};

int main() { 
    MyInt a5;
    std::cout << "a5[1] = " << a5[1] << std::endl;
}
```

#### (C++23) Множественное индексирование (или как превратить плюсы в Паскаль)
С C++23 можно перегружать квадратные скобки с множественным индексированием. Удобно, когда вы хотите сделать свой `std::vector<std::vector<...> >`!

```cpp
class MyInt {
    std::vector<std::vector<int> > vec_{};

public:

    MyInt()
    {
        vec_ = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    } 
    int& operator[](const int i, const int j)
    {
        return vec_[i, j];
    }
};

int main() { 
    MyInt a5;
    std::cout << "a5[1][1] = " << a5[1, 1] << std::endl;
}
```