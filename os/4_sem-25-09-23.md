# Семинар №4 - Cемейство функций stat, информация о файлах, работа со временем

## stat

Записывает в структуру аттрибуты состояния файла, указанного с помощью полного пути к нему или файлового дескриптора:
```c
#include <sys/types.h>
#include <sys/stat.h>

int stat(const char *pathname, struct stat *buf);
int lstat(const char *path, struct stat *buf) // link stat
int fstat(int filedes, struct stat *buf) // по файловому дескриптору
```

Функция `lstat` похожа на функцию `stat`, но когда ей передается имя символической ссылки, она возвращает сведения о самой символической ссылке, а не о файле, на который она ссылается. 

```c
#include <time.h>

struct timespec
{
    time_t tv_sec,
    long tv_nsec;
}
```

```c
struct stat
{
    ...
    mode_t st_mode;
    ...
}
```
в st_mode 4 + 3 + 9 бит, где

4 - тип файла
3 - sticky bits (стар - польз, сред - группа, млад - запрет)
9 - права доступа

S_IFMT - маска 4 бит
### 7 типов файлов:
- S_IFBLK - файл блоч. устр.
- S_IFCHR - файл стелв, устр.
- S_IFIFO - именной канал
- S_IFREG - "обычный" (текст, исполняемый, ...)
- S_IFDIR - директория
- S_IFLNK - симв ссылка
- S_IFSOCK - сокет

```c
buf->st_mode & S_IFMT == S_IFREG
```

### Макросы для типов файлов:
```c
S_ISREG(buf->st_mode)
```
Возвращает != 0, если регулярный
Возвращает == 0, если не регулярный

Права доступа лучше обозначать с помощью макросов
```c
S_I[R, W, X, RWX][USR, GRP, OTH]
```

Пример: `S_IROTH` - чтение для остальных пользователей

### Задача 1

Написать функцию с двумя аргументами (пути к файлам), которая возвращает:
- -1, если хотя бы 1 - не регулярный
- размер файла, если аргумент - инд. ссылки
- сумму размеров, если файлы разные

```c 
long long 
f(const char *f1, const char *f2) 
{
    struct stat b1, b2;
    stat(f1, &b1);
    stat(f2, &b2);
    if (!S_ISREG(b1.st_mode) || !S_ISREG(b2.st_mode)) {
        return -1;
    }
    if (b1.st_ino == b2.st_ino && b1.st_dev == b2.st_dev) {
        return b1.st_size;
    }
    return (long long)b1.st_size + (long long)b2.st_size;
}
```

## Работа со временем
Основная библиотека: `<time.h>`
```c
time_t time(time_t *buf)
``` 
Позволяет узнать текущее время
Возвращает:
- -1 - если произошла ошибка
- число секунд с начала Эпохи (1970)

```c
time_t t = time(NULL) 

time(&t);
```

```c
struct tm *localtime(time_t *time)
```
Позволяет конвертировать число секунд в наиболее привычный человеку вид.
Считает время в часовом поясе компьютера!
Если вернет NULL, то произошла ошибка.
```c
struct tm
{
    int tm_sec,  // секунды 0..60
                 // (почему 60? потому что високостная секунда)
    int tm_min,  // минуты 0..59
    int tm_hour, // часы 0..23
    int tm_mday, // день месяца 1..31
    int tm_mon,  // месяц 1..12
    int tm_year, // год 1900 + x, где x - значение поля
    int tm_wday, // день недели 0..6
    int tm_yday, // день в году 0..365
    int tm_isdst // is date saving time? - флаг перехода на летнее время
}
```

```c
struct tm *gmtime(time_t *time)
```

Возвращает время в часовом поясе Гринвича (по UTC)


time для разных часовых поясов вернет одинаковое число секунд!
localtime для разных часовых поясов вернет разный результат!


Нити: поток, (thread) - легковесный процесс
С многонитевыми программами возникают трудности! Используем в них:
```c
struct tm *localtime_r(time_t *time, struct tm *buf)
```
- эту функцию используем в Ejudge!

### Более точные таймеры
```c
int clock_gettime(clockid_t cid, struct timespec *pt)
```
Записывает в `pt` время, которое отмеряет таймер `cid`.
Возвращает 0, если все прошло успешно;
Возвращает -1, если произошла ошибка
`cid`:
- `CLOCK_REALTIME` - текущее время
- `CLOCK_PROCESS_CPUTIME_ID` - время работы процесса

```c
int clock_getres(clockid_t cid, struct timespec *pt)
```
Позволяет узнать разрешающую способность часов, указанных в аргументе `clock_id`.
В `pt` будет записан минимальный интервал времени, который могут замерить указанные часы.
Возвращает 0, если все прошло успешно;
Возвращает -1, если произошла ошибка
`cid`:
- `CLOCK_REALTIME` - текущее время
- `CLOCK_PROCESS_CPUTIME_ID` - время работы процесса

### "Обратные" функции (из человеческого формата в секунды)
```c
time_t mktime(struct tm *tmptr);
```
Возвращает число секунд с начала Эпохи по локальному времени `tm`.

```c
time_t timegm(struct tm *tmptr);
```
Возвращает число секунд с начала Эпохи по UTC-времени `tm`.

### Из struct tm в строку
```c
size_t strftime(char *buf, size_t maxsize, const char *format, const struct tm *tmptr);
```

Возвращает количество символов, записанных в массив, если в нем достаточно места, в противном случае возвращает 0

Последний аргумент функции – указатель на структуру tm, содержащую время, которое должно быть представлено в виде отформатированной строки. Результат форматирования сохраняется в буфере buf, размер которого определяется аргументом maxsize. Аргумент format управляет форматированием значения времени. Как и в случае с функцией printf, спецификаторы формата начинаются с символа процента, за которым следуют служебные символы. Все остальные символы в строке format выводятся без изменений. Два символа процента, следующие друг за другом, будут отображаться как один символ процента. В отличие от функции printf, каждый спецификатор формата генерирует на выходе строки фиксированного размера – спецификаторы ширины поля вывода не предусмотрены.

- %A - название дня недели
- %B - название месяца
- %c - дата и время
- %d - день
- %H - час
- %M - минуты
- %S - секунды
- %n - '\n'
- %x - локализованная дата
- %X - локализованное время
- %r - локализованное 12-часовое время
- %Y - год в виде десятичного числа (2023)
- %c - стандартные дата и время
- %% - '%'

## Проклятая задача (на подумать)
Посчитать количество пятниц 13-х в году.
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

int
main(int argc, char *argv[])
{
    int counter = 0;
    int year = strtol(argv[1], NULL, 10);
    for (int i = 1; i <= 12; ++i) {
        struct tm t = {};
        t.tm_year = year - 1900;
        t.tm_mon = i - 1;
        t.tm_mday = 13;
        t.tm_isdst = -1;
        timegm(&t);
        if (t.tm_wday == 5) {
            ++counter;
        }
    }
    printf("%d\n", counter);
}
```
