# Файловый ввод/вывод
## Интерфейс
Используется указатель на дескриптор: ``FILE *f;``

Чтобы открыть файл, используется функция `fopen`:

```c
FILE *f = fopen("file.txt", "r");
// Если f ненулевой, то с этим дескриптором можно работать
// первый параметр - путь к файлу (если не указан полный путь, то
// откроется файл в рабочей директории)
// второй параметр - режим работы:
```
- "r" - чтение
- "w" - запись (курсор устанавливается в НАЧАЛО файла, то есть содержимое будет перезаписано)
- "a" - дописывание (курсор устанавливается в КОНЕЦ файла, то есть вы будете записывать данные в конец файла
- "r+" - чтение+запись
- "w+" - создание и запись, чтение (создаст файл, если его нет)
- "a+" - дописывание и чтение
- "b" - то же самое, но с бинарным файлом

## Спецсимволы
- \n - перенос строки
- \r - возврат каретки

## Антипод эфоупена, или как закрывать файлы
Evil fopen be like:

```c
int fclose(f); // закроет файл
fflush(f); // ОС записывает данные БЛОКАМИ, поэтому иногда возникают ситуации,
// когда ОС не успевает записать данные и эти данные пропадают.
// fflush выручает в таких ситуациях
// непонятно? прочитайте еще в интернетах 
```

## Ок, а как считывать файл-то? 
Тривиально.

```c
int fscanf(FILE *f, char *fmt, ...);
int fgets(FILE *f); // возвращает символ или константу EOF, если не удалось 
//                     прочитать символ(обычно EOF = -1)
char *fgets(char *s, int n, FILE *f); // чтение целой строки до \n
```

## А записывать?
Очевидно.

```c
int fprintf(FILE *f, char *fmt, ...);
int fputs(int c, FILE *f); // выводит символ
int fputs(char *s, FILE *f); // запись строки в файл
```

## Функции с еофом)

```c
int feof(FILE *f); // вернет положительное значение, если дескриптор прочитал
//                    весь файл

int ferror(FILE *f); // если в процессе чтения или записи возникла ошибка, то
//                      вернет ненулевое значение
```

## Детская задача
Посчитать сумму чисел в файле

```c
FILE *f = fopen("numbers.txt", "f");
int res = 0, x;
while (fscanf(f, "%d", &x) == 1) {
    res += x;
}
fclose(f);
```

## Влияем на позицию дескриптора
```c
long int ftell(FILE *f); // покажет позицию курсора в файле

int fseek(FILE *f, long int off, int whence);
// off - на сколько байт смещаться
// whence - относительно ЧЕГО смещение
// SEEK_SET - остносительно начала файла (смещение на заданную пощицию в файле)
// SEEK_CUR - относительно текущей позиции в файле
// SEEK_END - относительно конца файла
```

## Великая троица потоков ввода/вывода
У си есть три потока:

```c
FILE *stdin; // поток ввода
FILE *stdout; // поток вывода (буферизуется)
FILE *stderr; // поток ошибок (не буферизуется!)

fscanf(stdin, ...)
```

## Работа с бинарными файлами
```c
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *f);
// пытается считать из файла nmemb элементов размера size и записывает их в ptr
// возвращает количество успешно считанных элементов

size_t fwrite(void *ptr, size_t size, size_t memb, FILE *f);
// то же самое, только записывает
// возвращает число успешно выведенных элементов размера size 
```

## Детская задача 2
Посчитать сумму чисел бинарного файла

```c
#include <stdio.h>
FILE *f = fopen("numbers.txt", "rb");
int sum = 0, x;
while (fread(&x, sizeof(int), 1, f) == 1) {
    sum += x;
}
fclose(f);
```

### Задачка для выпускников детского сада
Считать за наименьшее число проходов байты; посчитать количество нулевых байт

```c
FILE *f = fopen("input.txt", "rb");
char s[512], symb;
int n = 0;
size_t size;
while ((size = fread(s, 1, 512, f)) == 512) {
    for (int i = 0; i < 512; i++) {
        if (s[i] == 0) n += 1;
    }
}
for (int i = 0; i < size; i++) {
    if (s[i] == 0) n += 1;
}
```