# Строки
Как хранятся строки:
 
* `|s|t|r|i|n|g|\0|` - всегда заканчиваются \0 
* BSTR - `|6|_|s|t|r|i|n|g|`

```c
const char *s;
```

## Челлендж)
Написать функцию, которая подсчитывает длину строки

```c
// Способ с циклом
int len(char *s){int r=0;while(s[r++]);return r;}

// Рекурсия: подержи-ка мое пиво
int f(char *s){return *s?f(s+1)+1:0;}
```

Библиотечная функция:

```c
#include <string.h>
// ...
strlen(const char *s);
```

## Инициализация строк
```c
char s[] = "string";
const char *p = "string";
```

## Челлендж) 2
Скопировать содержимое первой строки во вторую строчку. Гарантируется, что вызывающий эту функцию юзверь выделил достаточно памяти для второй строки.

```c
// Average циклы fan
void c(char *s, char *d){do{*d++=*s;}while(*s++);}

// Average рекурсия enjoyer
void c(char *s, char *d){if(*d=*s)c(s+1,d+1);} 

// Очередная победа рекурсии
```

## Копирование строк
```c
char *strcpy(char *d, const char *s);
// Прогер, используя эту функцию, должен гарантировать, что выделено достаточно памяти для d.

// К счастью, есть замечательная функция (опять с подвохом: скопирует максимум n байт, но если она дошла до n-го символа, то может не записать нуль-терминатор в конце.
char *strncpy(char *d, const char *s, size_t n);

// Как ее безопасно вызвать:
strncpy(d, c, n - 1);
d[n - 1] = 0;
// Майка с аниме-тян Дмитрия Михайловича: Нужно всегда предохраняться! Используй strncpy!
```

## Сравнение строк
```c
int strcmp(const char *s1, const char *s2);
// Отрицательна, если лексикографически s1 < s2
// Равна нулю, если лексикографически s1 = s2
// Положительна, если лексикографически s1 > s2

int strncmp(const char *s1, const char *s2, size_t n);
// strncmp сравнивает первые n символов

int stricmp(...)
// stricmp сравнивает строки, не обращая внимания на регистр символов, то есть 'A' = 'a'
```

## Ввод-вывод строк
```c
int gets(char *s); 
// Эта функция небезопасна: может произойти переполнение буфера. Я вам запрещаю использовать gets!

char *fgets(char *s, int size, FILE *f); // *f = stdin, если мы хотим ввод из консоли(стандартный поток ввода)
// Эта функция - ваш друг. ВСЕГДА запишет нуль-терминатор в конце.

char s[20];
scanf("%19s", s); // 19 - сколько максимально символов запишется в s(20-й символ - нуль-терминатор)

int puts(const char *s); // Самая простая функция! Просто выводит на экран строку s. Че-то там возвращает.
int printf("%s", s); // Можно так

printf(s); // эквивалентно printf("Hello world");
// НО! Если в строке s есть символ '%', то последствия непоправимы(шучу, просто функция printf будет некорректно работать, так как, увидев %, она не сможет обратиться к аргументу)

int sprintf(char *s, const char *fmt, ...);
// Запишет в строку ту же самую последовательность, что в printf. ОПЯТЬ НЕБЕЗОПАСНО!
int snprintf(char *s, size_t n, ...); // Ваш надежный(!) покорный слуга
```

```c
char *strchr(const char *s, int c); // char in string (о, вы из Англии)
// находит символ в строке. Возвращает NULL, если не найдет его, и возвращает адрес на символ в строке.
char *strrchr(...) // Нет, это не очередная безопасная версия strchr. Просто ищет символ задом наперед(привет Нолану)

char *strstr(const char *s1, const char *s2) // ищет первое вхождение строки s2 в строке s1
char *strrchr(...) // Нолановская версия функции strstr

char *strtok(char *s, const char *s2); // Разбивает строку по символам s2
p = strtok(s, ","); // в p запишется конец строки s, в s - начало строки s
q = strtok(p, ",");
r = strtok(q, ",");
// ... и так далее
```

## Челлендж) 3
Вася уснул за компом и зажал капслок: преврати все строчные буквы в заглавные!

```c
void f(char *s){ 
    while (*s) {
        if (('a' <= *s) && (*s <= 'z')) {
            *s = 'A' + *s - 'a';
        }
        s++;
    }
}
```
