# Списки
Казалось бы, массив - ультимативное решение для хранения последовательностей данных. Но у него есть недостатки:
- Нельзя "безболезненно" вставить еще один элемент в середину массива (дороговатая операция)
- Нельзя быстро удалить элемент (опять же, дорого!!$$$$$$$)

К счастью, наши шизопредки изобрели **списки**.

С их помощью вставка элементов происходит *довольно* быстро!

```c
struct list {
    int data;
    struct list *next;
}

...

struct list *head; // указатель на начало списка

...

for (struct list *p = head; p->next != NULL; p = p->next) {
    // Вот таким нехитрым образом можно обойти все элементы списка
    p->data = 119; 
}
```

## "Как же утомительно писать каждый раз struct list!!!"
2 миски риса этому внимательному господину!

typedef нас в очередной раз выручит:
```c
typedef struct list {
    int data;
    struct list *next;
} list;

...

list *head; // другое дело!
```

## Задачка для первоклассников
Найти в непустом списке минимальный элемент.
```c
list *p = head;
int mn = head->data;
for (p = head->next; p; p = p->next) {
    mn = min(mn, p->data);
}
mn = min(mn, p->data);
```

# Кольцевой список

Можно заметить, что никто не может нам помешать сделать так, чтобы указатель `next` последнего элемента указывал на первый элемент. Не знаю, зачем это может пригодиться, но почему бы и нет?

## Задачка для второклассников
Найти количество элементов кольцевого списка.
```c
list *p = head;
int count = 1;
for (; p->next != head; p = p->next, ++count)
    ;
```

# Как модифицировать список?
```c
void list_update(list **head, ...) { // ОБРАЩАЕМ ВНИМАНИЕ НА **
    ... // Иначе изменить исходный список нельзя!
}

// А вообще, забудьте прошлые три строчки и изменяйте список вот так:
list *list_update(list *head, ...) {
    ...
}
```
Кстати говоря, для удобства можно хранить указатель на последний и первый элементы:
```c
struct real_list {
    int num; // Сколько элементов в списке
    list *head; // храним указатели на первый, и последний элемент
    list *tail;
}
```

## Задачка для третьеклассников
Составить из 8 чисел список. 
```c
list *head = malloc(sizeof(list)), *p = head;
for (int i = 0; i < 8; i++) {
    scanf("%d", &(p->data));
    if (i != 7) {
        p->next = malloc(sizeof(list));
        p = p->next;
    } else {
        p->next = NULL:
    }
}
```

## Инвертированная задачка от Нолана для четвероклассников
То же самое, только дерепаН модаЗ
```c
list *head = malloc(sizeof(list)), *p = head;
for (int i = 0; i < 8; i++) {
    scanf("%d", &(p->data));
    list *ls = malloc(sizeof(list));
    ls->next = p;
    p = ls;
}
```

# Шутки кончились,
*или очередная задачка для пятиклассников*

Написать функцию, удаляющую элементы с определенным значением.
```c
list *Remove(list *ptr, int x) {
    if (ptr) {
        ptr->next = Remove(ptr->next, x);
        if (ptr->data == x) {
            list *next = ptr->next;
            free(ptr);
            ptr = next;
        }
    }
    return ptr;
}
```

**Работа со списками в рекурсии - залог успеха!**

## "Злободневная" задача для шестиклассников
Вставить перед элементом с 2023 элемент с 2022. **Иногда некоторые даты невозможно забыть.**

PS: Мем с семинара: "Забудьте про newYear! Теперь у вас есть только pastYear!"
```c
list *pastYear(list *ptr) {
    if (ptr) {
        ptr->next = pastYear(ptr->next);
        if (ptr->data == 2023) {
            list *node = malloc(sizeof(list));
            node->data = 2022;
            node->next = ptr;
            ptr = node;
        }
    }
    return ptr;
}
```

# Проблемс для семиклассников, или удаление списка
Удалите все элементы списка.

Цитаты великих людей: "Добейте. *Выживших*."
```c
list *next;
list *head;
list *p;
p = head;
while (p) {
    next = p->next;
    free(p);
    p = next;
}
```

# Домашка
Дан список. Проверить, закольцован ли односвязный список. Этот список может быт закольцован не только на начальный элемент!

Шаблон функции:
```c
int check(const list *p) {
    ...
}
```