# Куча тем(так и написали)
## Записи - struct
struct - композитная структура данных, у которой есть набор полей(переменных разных типов):

```c
struct student {
    char name[80];
    int group;
    int grade;
} s, *p; 
// *p - указатель на участок памяти, где хранится структура student
// s - сама структура
// после } мы можем не объявлять новые переменные типа struct student

struct student ivanov = {"Ivanov", 103, 14}, *p = &ivanov;
// через такое объявление можно присваивать значения полей

s1 = s2; // присваивание работает через побитовое копирование 

ivanov.group = 104; // обращение к полям структуры ivanov


//НОВЫЙ ОПЕРАТОР:
p->group = 105; 
// ЭКВИВАЛЕНТНО
(*p).group = 105;

// Так разработчики языка СИ позаботились о бедных прогерах и добавили 
// для них некий синтаксический сахарок.

```


## Байты выравнивания (коварные)

```c
// Из-за коварных байтов выравнивания нельзя написать это: 
memcmp(&s1, &s2, sizeof(struct student));
// Подумайте, почему? 



// или не думайте: https://stackoverflow.com/a/141791
// надеюсь, вы знаете инглиш)
```


## Челлендж)
```c
// Дана структура: 
struct date {
    int year;
    int month;
    int day;
}

// Напишите функцию вывода даты

void print_date(struct date date) {
    printf("%d-%d-%d", date.year, date.month, date.day);
}
// Коварный момент: в данной реализации переданная в качестве параметра 
// струтура КОПИРУЕТСЯ в date, и в случае с огромной структурой прога будет
// работать долговато. И тут решить сей проблемс нам помогают указатели:

void print_date_s(struct date *date) {
    printf("%d-%d-%d", date->year, date->month, date->day);
}
```

## Объединения (более хитрая тема)
Объединения - очень хитрая штука:

```c
// Объявляем объединение
union number {
    float f;
    int n;
} 

// ...

union number x;

x.f = 0.0;
x.n = 1;
```

"Для чего это нужно?" - именно этот вопрос задает каждый читатель. Умерьте свой пыл: объяснение существования данной конструкции будет!

## Перечисления

Просто перечисление неких констант:

```c
enum answer {
    YES, // Нумерация и тип данных ЗАВИСИТ от Компилятора!!!!
    NO, 
    MAYBE
};

// После объявления мы можем использовать эти слова как константы
enum answer ans = YES;

// К сожалению, кто-то так действительно пишет
enum answer ans_what = -1;
// Так писать НЕ НАДО! Если вы все-таки это напишете, знайте: я вас найду.

// Хотите точности? Объявляйте значения!
enum answer {
    YES = 32,
    NO = 64, 
    MAYBE,
    MAX = MAYBE
};
```

## Время ***примеров***!

Вся эта радость используется для прикольной штуки:

```c
struct shape {
    enum shape_kind {
        CIRCLE, 
        RECT
    } kind; // либо КРУГ, либо ПРЯМОУГОЛЬНИК
    union {
        struct {double w, h;} rect;
        struct {double r; } circle;
    } u; // это объединение описывает либо прямоугольник со сторонами w и h,
    // или круг с радиусом r
}
// Некоторым читателям это могло напомнить наследование в парадигме ООП
// и они будут чертовски правы!


// Вот таким нехитрым образом можно написать функцию расчета площади любой
// фигуры:
double S(struct shape *s) {
    if (s->kind == CIRCLE) {
        return 3.14 * s->u.circle.r * s->u.circle.r;
    }
    else {
        return s->u.rect.w * s->u.rect.h;
    }
}
```

## Небольшой ликбез по хранению данных в памяти
```
Возьмем число 0x01020304.

Если платформы, которые хранят это число так: |04|03|02|01| - little-endian
(старший разряд справа)
и наоборот: |01|02|03|04| - big-endian (старший разряд слева)

```

```c
union {
    int i;
    int c;
} x;

// ...

x.i = 0;
x.c = 1;
if (x.i == 1) { // если младший байт расположен слева
    //little-endian
} else {
    //big-endian
}
```

## Массивы переменной длины в структурах
Людям хотелось еще с древних времен - с первых версий языка Си - хранить в структурах массивы с произвольным количеством байт, а не определенным изначально.
Наши шизопредки решали эту проблему так:

```c
struct student {
    int id;
    int grade;
    char name[1]
}

malloc(sizeof(struct student) - 1 + strlen(name) + 1);
```

И после такого в сообществе разработчиков компиляторов начался **кошмар**. Они увидели сей ужас и в C99 реализовали flexible array member:

```c
struct student {
    int id;
    int grade;
    char name[];
} s;
```

### Внезапная задача
Реализуйте функцию new:

```c
struct student *new(int id, int grade, char *name) {
    struct student *p = malloc(sizeof(struct student));
    p->id = id;
    p->grade = grade;
    p->name = (char *)malloc(strlen(name));
    strcpy(p->name, name);
    return p;
}
```

## Удобные имена

Иногда программист устает от бесконечной писанины struct name. Специально для него разработали typedef:

```c
typedef struct student sst;
// после этого мы можем объявлять новую переменную так:
sst s;

// Кроме того, вы можете так переопределять базовые типы:
typedef long long ll;

// Страшно представить, сколько байт в размере Си-файла вы сэкономили 
// одной строчкой...
```