# 10.05.23 / Основы работы с UNIX-терминалом и утилитой GDB

Каждый уважающий себя прогер должен уметь общаться с терминалом на ты: без него в даже в нашу эпоху GUI не обойдешься - уж больно он удобный и многофункциональный!

#### :bangbang: Важно
- В данном конспекте значком доллара `$` в начале строки будут обозначаться введеные пользователем команды.

## Основные команды UNIX-терминала
### pwd (Print Working Directory)
Позволит тебе понять, в какой директории ты сейчас находишься.
```
$ pwd 
/Users/nikit/Projects/cmc-prac-student-notes/asm
```

### ls (LiSt)
Покажет все, что находится в рабочей папке.
```
$ ls 
10_26-04-23_floating_point.md                      3_01-03-23_jumps_and_labels.md                     8_12-04-23_file_input_output.md
11_03-05-23_args_linking_preprocessor_libs_make.md 4_15-03-23_pointers_and_arrays.md                  9_19-04-23_floating_point.md
12_10-05-23_tty_gdb.md                             5_22-03-23_stack_and_cdecl.md                      src
1_15-02-23_mov_and_math.md                         6_29-03-23_cdecl_examples_and_struct_align.md
2_22-02-23_bits_and_jumps.md                       7_05-04-23_standard_functions_call_and_lists.md
```

#### Флаг -l
С этим флагом команда `ls` выведет более читабельный список, в котором будут показаны права доступа к нему, авторы, размеры файлов и дата создания.

```
$ ls -l
total 312
-rw-r--r--   1 nikit  staff  14781 29 апр 20:38 10_26-04-23_floating_point.md
-rw-r--r--   1 nikit  staff  17337 13 май 00:33 11_03-05-23_args_linking_preprocessor_libs_make.md
-rw-r--r--   1 nikit  staff   1824 13 май 13:07 12_10-05-23_tty_gdb.md
-rw-r--r--   1 nikit  staff  24744  1 апр 19:48 1_15-02-23_mov_and_math.md
-rw-r--r--   1 nikit  staff  10960  1 апр 19:47 2_22-02-23_bits_and_jumps.md
-rw-r--r--   1 nikit  staff   9971  5 апр 18:27 3_01-03-23_jumps_and_labels.md
-rw-r--r--   1 nikit  staff   5935  1 апр 18:47 4_15-03-23_pointers_and_arrays.md
-rw-r--r--   1 nikit  staff  14111  5 апр 19:03 5_22-03-23_stack_and_cdecl.md
-rw-r--r--   1 nikit  staff   5037  1 апр 18:54 6_29-03-23_cdecl_examples_and_struct_align.md
-rw-r--r--   1 nikit  staff   5966  5 апр 21:20 7_05-04-23_standard_functions_call_and_lists.md
-rw-r--r--   1 nikit  staff   5552 29 апр 20:26 8_12-04-23_file_input_output.md
-rw-r--r--   1 nikit  staff  13113 26 апр 13:20 9_19-04-23_floating_point.md
drwxr-xr-x  19 nikit  staff    608 12 май 22:16 src
```

#### :bangbang: Важно
- На некоторых системах вместо `ls -l` можно писать `ll`.

### cd (Change Directory)
Перейдет в директорию, указанную в параметре.
```
$ cd <directory>
```
Можно указывать *абсолютный* и *относительный* пути.

- Абсолютный путь

Просто полный путь к папке:
```
$ cd ~/Projects/cmc-prac-student-notes/asm/src
```
Так мы можем переходить независимо от того, в какой папке мы сейчас находимся.

- Относительный путь

Относительно нашей рабочей директории, где мы сейчас находимся.
К примеру, если я сейчас нахожусь в `~/Projects/cmc-prac-student-notes/asm`, а мне нужно перейти в `~/Projects/cmc-prac-student-notes/asm/src`, то я просто пишу:
```
$ cd src
```

А если я сейчас нахожусь в `~/Projects/cmc-prac-student-notes/`, а мне нужно перейти в `~/Projects/cmc-prac-student-notes/asm/src`, то я просто пишу:
```
$ cd asm/src
```
Чаще всего гулять по папкам мы будем через относительный путь.

#### Автодополнение
Для удобства юзверя: нажатие клавиши `Tab` при наборе имени папки/файла дает системе команду подставить наиболее вероятные названия СУЩЕСТВУЮЩИХ папок/файлов. Еще раз нажимая клавишу `Tab`, вы перебираете другие возможные варианты. Как только они кончатся, система начнет заново предлагать.

Еще лучше понять эту крайне интересную фичу можно только через практику (никак иначе!).

#### Переход наверх
А если мы хотим подняться наверх? Тогда мы ставим две точки в качестве аргумента:
```
$ cd ..
```

А если мы хотим ДВАЖДЫ подняться наверх? Тогда мы ставим две точки, слэш и еще две точки в качестве аргумента:
```
$ cd ../..
```

... и так далее до бесконечности.

### mkdir (MaKe DIRectory)
Хотите создать папку? `mkdir` поможет Вам в этом деле:
```
$ mkdir directory
```
Так мы создали в рабочей директории папку `directory`. Теперь перейти в нее можно с помощью команды `cd directory`.

Кроме того, здесь можно указывать абсолютный и относительный пути. То есть можно создать папку, находясь в другой папке! ~~лол~~

### touch 
Хотите создать файл? `touch` поможет Вам в этом деле:
```
$ touch file.c
```
Так мы создали в рабочей директории ПУСТОЙ файл `file.c`. 

[Здесь можно почитать о других возможностях команды `touch`.](https://lumpics.ru/command-touch-in-linux/?ysclid=lhlurq42qm16526351)

### rm (ReMove)
:bangbang: САМАЯ ОПАСНАЯ КОМАНДА EVER!

Файл или папка больше не нужны? Удаляем их при помощи команды `rm`:
```
$ rm temp.log
$ rm -r hated_directory
```
Обратите внимание, что для удаления директории нужно ставить флаг `-r`.

Если мы хотим удалить все файлы в рабочей папке, используем шаблонную запись `*`:

```
$ rm *
```

#### Другие флаги 
- `-f` или `--force` - ~~сильный флаг~~ никогда не выдавать запросы на подтверждение удаления, игнорировать несуществующие файлы и аргументы.
- `-i` - выдавать запрос на удаление КАЖДОГО файла.
- `-I` - выдать ОДИН запрос на удаление ВСЕХ файлов, если файлов больше трех или используется рекурсивное удаление.
- `-r` или `-R` или `--recursive` - рекурсивное удаление директорий и их содержимого.
- `-d` или `--dir` - удалять пустые папки.

#### :bangbang: Важно
- Если заядлый линуксоид предлагает вам запустить команду `rm -rf /`, то НЕ ВЕДИТЕСЬ! ТАК ВЫ УНИЧТОЖИТЕ LINUX!

### Внезапный мем
Когда случайно запустил команду `rm -rf /`:

![Упс :(](src/death_of_linux.jpeg "Упс :(")

### cp (CoPy)
Копирование файлов (и директорий с `-r`):
```
$ cp <что копировать> <куда копировать>
```

#### Пример (находимся в `~/Projects`)
```
$ cp file.txt ~/Documents/important
```
Можно сразу переименовать файл: 
```
$ cp file.txt ~/Documents/important/text.txt
```
#### :bangbang: Важно
- Если в <куда копировать> файл с таким именем уже есть, то система просто перезапишет его, НИЧЕГО НЕ СПРАШИВАЯ У ЮЗВЕРЯ!


#### Копируем директории
Просто добавьте флаг `-r` (рекурсивное копирование):
```
$ cp -r  <путь_к_папке>  <путь_к_другому_месту>
```

### mv (MoVe)

Просто перемещение (а не копирование) файлов и директорий.
```
$ mv <что перемещать> <куда перемещать>
```
#### Пример (находимся в `~/Projects`)
```
$ mv file.txt ~/Documents/important
```
Можно сразу переименовать файл: 
```
$ mv file.txt ~/Documents/important/text.txt
```
#### Перемещаем директории
Добавлять флаг `-r` здесь НЕ нужно:
```
$ mv <путь_к_папке> <путь_к_новому_месту>
```

### cat (CATenate)
Читает данные из файла или стандартного ввода и выводит их на экран.
```
$ cat <флаги> <файл 1> <файл 2> ...
```
#### Основные флаги
- `-b` - нумеровать только непустые строки;
- `-E` - показывать символ $ в конце каждой строки;
- `-n` - нумеровать все строки;
- `-s` - удалять пустые повторяющиеся строки;
- `-T` - отображать табуляции в виде `^I`;
- `-h` - отобразить справку;
- `-v` - версия утилиты.

### wc (Word Count)
Подсчитывает число слов или строк в тексте.

```
$ wc <флаги> <файл1> <файл2> ...
```

Если мы не указываем файлы команде, то она будет ожидать ввода данных. После ввода `Ctrl+D` командный интерпретатор завершит работу команды и выведет три числа: количество строк, слов и байт введенной информации.

#### Основные флаги
- `-l` - вывести количество строк в объекте;
- `-w` - вывести количество слов в объекте;
- `-c` - вывести размер объекта в байтах;
- `-m` - вывести количество символов в объекте;

### sort (SORT ¯\\\_(ツ)_/¯)
Сортирует текстовые строки в алфавитном или нумерологическом порядке.

```
$ sort <флаги> <файл1> <файл2> ...
```

[Более подробно про флаги и разнообразные применения этой замечательной команды смотри здесь.](https://aidalinux.ru/w/Sort)

### echo (ECHO ¯\\\_(ツ)_/¯)
Просто отображает строку текста.
```
$ echo <флаги> <строка>
```
#### Основные флаги
- `-n` - не выводить перевод строки;
- `-e` - включить поддержку Escape-последовательностей;
- `-E` - отключить поддержку Escape-последовательностей;

#### Пример ~~(Понасенков одобряет (*является иноагентом*))~~
```
$ echo I love Paris!
I love Paris!
```

Казалось бы, простая команда, но она очень нам поможет в конвейерах (сорри за спойлеры)...

### grep (search Globally for lines matching the Regular Expression, and Print them)
Маст-хэв для любого линуксоида. Используется для фильтрации текста.
Без флагов программа выводит строки, содержащие вхождение шаблона.
```
$ grep <флаги> <шаблон> <файл1> <файл2> ...
```

#### Основные флаги
- `-i` - игнорировать регистр символов;
- `-v` - вывести только те строки, в которых шаблон поиска не найден (инверсия!);
- `-w` - искать шаблон как слово, отделенное пробелами или другими знаками препинания;
- `-x` - искать шаблон как целую строку, от начала и до символа перевода строки; 
- `-l` - выводить только имена файлов, в которых есть хотя бы одно вхождение шаблона;
- `-L` - выводить только имена файлов, в которых НЕТ НИ ОДНОГО вхождения шаблона;
- `-r` - рекурсивный поиск по всем подпапкам;
- `-a` - интерпретировать двоичные файлы как текст;
- `-I` - пропускать двоичные файлы;
- `-G` - интерпретировать шаблон поиска как базовое регулярное выражение (BRE);
- `-F` - интерпретировать шаблон поиска как обычную строку, а не регулярное выражение;

[Более подробно про разнообразные применения этой нужной всем команды смотри здесь.](https://habr.com/ru/articles/229501/)

### sed (Stream EDitor)
Потоковый редактор текста, позволяющий проводить с текстом операции поиска и замены, вставки и удаления, не запуская Vim. Кроме того, sed поддерживает регулярные выражения.
```
$ sed <flags> <script> <file1> <file2> ...
```
#### Основные флаги
- `-n` - выводить только те строки, в которых выполнялась замена;
- `-r` - включить поддержку расширенного синтаксиса регулярных выражений;
- `-f` - прочитать команды редактирования из файла;
  
#### Примеры операций
1. Поиск и замена - `s/<что ищем>/<на что заменяем>[/...]`

По умолчанию заменяется первое вхождение шаблона в каждой строке, а второе/третье/.../n-ое не затрагиваются:
```
$ sed 's/zero/one' file.txt
```

Если нам нужно заменить другое вхождение, ставим флаг `/число`. То есть, если мы хотим заменить четвертое вхождение, пишем:
 ```
$ sed 's/zero/one/4' file.txt
```

Если нам нужно заменить ВСЕ вхождения, ставим флаг `/g` (global):
```
$ sed 's/zero/one/g' file.txt
```

Если нам нужно заменить ВСЕ вхождения, начиная со второго, то ставим флаг `/2g`:
```
$ sed 's/zero/one/2g' file.txt
```

Если мы хотим заменить не во всех строках, а в какой-то одной, то дописываем номер строки слева (в примере четвертая строка):
```
$ sed '4 s/zero/one' file.txt
```

Мы также можем указать диапазон строк. Замена с 4 по 8 стр.:
```
$ sed '4,8 s/zero/one' file.txt
```

Замена с третьей строки и до конца файла (`$` указывает на последнюю строку файла)
```
$ sed '3,$ s/zero/one' file.txt
```

Флаг `/p` выведет (еще раз) строки, в которых происходила замена:
```
$ sed 's/zero/one/p' file.txt
```

Если мы с флагом `/p` добавим флаг `-n`, то в терминале будут выведены только строки, в которых происходила замена. Дублирования при этом не будет:
```
$ sed -n 's/zero/one/p' file.txt
```

2. Удаление - `...d`

Удаляем вторую строку: 
```
$ sed '2d' file.txt
```
Удаляем последнюю строку: 
```
$ sed '$d' file.txt
```
Удаляем диапазон строк:
```
$ sed '4,8d' file.txt
```

[Более подробно про разнообразные применения этой полезной команды смотри здесь.](https://habr.com/ru/companies/ruvds/articles/667490/)

### which (WHICH ¯\\\_(ツ)_/¯)
Каждая команда - исполняемый файл. `which` покажет, где именно расположен этот исполняемый файл:

```
$ which [-a] <file1> <file2> ... 
```

По умолчанию `which` выводит только один путь для своих аргументов. Если программа имеет исполняемый файл в нескольких местах, то при помощи флага `-a` `which` выведет все пути к файлам.

### man (MANual)
`man` позволяет узнать юзверю всю необходимую информацию по команде, функции или программе. (не залезая на stackoverflow!)
```
$ man <раздел> <название страницы>
```

Вы даже можете узнать, как работать с `man`:
```
$ man man
```

Это очень полезная программа! С помощью нее вы можете не только "загуглить" программы и команды linux, но и Си-функции:

```
$ man printf
```

Теперь вы знаете **всё на этом свете**.
## Коротко о конвейере (pipe)
Иногда прогер может захотеть взять то, что вывела одна команда, и передать это на входу другой команде (и так до бесконечности).

Как это можно реализовать? 

### Во-первых, то же возвращает команда?
1. Результат выполнения команды (то есть текстовые данные, которые запросил пользователь)
2. Сообщения об ошибках (информация о процессе выполнения команды и возникших исключениях)
3. Код возврата (число, обозначающее правильность выполнения команды. 0 означает успешное выполнение команды)

Не забываем, что в Linux все является файлом (даже потоки ввода/вывода). 

#### Интересный факт про коды возврата 
Если мы хотим узнать, какой код вернула предыдущая команда, то нам в этом деле поможет `echo`:
```
$ echo $?
```
Здесь `$?` - код возврата предыдущей выполненной команды.

А этот короткий bash-скрипт (`exit 13`) ничего не сделает, кроме того, что вернет код 13:
```
$ sh -c 'exit 13'
```

### Во-вторых, как результат выполнения одной команды можно передать другой команде на вход?

**Конвейер (pipe)** - однонаправленный канал межпроцессного взаимодействия. Как можно заметить, термин отсылает нас к трубопроводу, и это неспроста.

Конвейеры используются для связи двух и более команд через перенаправления вывода одной команды (`stdout`) на вход последующей (`stdin`). Делается это через вертикальную черту `|`:

```
команда1 | команда2 | команда3 | ... | командаN
```

#### Пример
```
cat file.c | sort | grep include | sed 's/include/import/g'
```
Здесь мы:
1. считываем файл `file.c`
2. сортируем его строки
3. берем только строки, содержащие `include`
4. Заменяем все вхождения `include` на `import`


## Последовательное выполнение команд
Если вы желаете запустить одним махом несколько команд, то `;` поможет вам в этом деле:
```
команда1 ; команда2 ; ... ; командаN
```
#### Пример:
```
echo text ; false
```
Выведет сначала `text`, потом вернет код 1. (`true` в свою очередь вернул бы 0. После Си парадоксально выглядит, не так ли?)

## Зависимое выполнение команд
`&&` и `||` означают ровно то же самое, что и логические И и ИЛИ.

Здесь каждая следующая команда выполнится только при успешном завершении предыдущей.
```
команда1 && команда2 && ... && командаN
```

А здесь каждая следующая команда выполнится если предыдущая команда вернет ошибку.
```
команда1 || команда2 || ... || командаN
```

## Ветвления
Тут все как обычно. Правда, к синтаксису нужно привыкнуть:
```
if условие; then команда; fi
if условие; then команда1; else команда2; fi
if условие1; then команда1; elif условие2; then команда2; else команда3; fi
```

Содержимое в условии может быть любой командой, если она дает код выхода (то есть, все команды). Как говорилось ранее, код выхода `0` эквивалентен `true`, а любой другой код - `false`. 

Но что именно делает ветвления в bash-скриптах действительно похожими на ветвления в Си?
### Семейство скобочек!
Перед тем, как познакомиться с этим семейством, нам нужно разобраться с командой test.

#### test (TEST ¯\\\_(ツ)_/¯)
Эта команда используется для проверки типа файла и сравнения значений.
Вернет 0 в случае истины и 1 в случае лжи.

```
$ test <выражение>
```

Обычно для сокращения кода используют следующий синтаксический сахар: в начале вместо `test` ставят парный оператор `[`, а в конце выражения ставят `]`. Обратите внимание, что парный оператор требует пробела между скобками, так как `[` является командой.

#### Проверка типов файлов и сравнение их дат модификации
- ` -f filename ` - вернет истину, если `filename` существует и является обычным файлом.
- ` -e filename ` - вернет истину, если `filename` существует.
- ` -s filename ` - вернет истину, если `filename` существует и имеет ненулевой размер.
- ` -d filename ` - вернет истину, если `filename` существует и является директорией.
- ` -r filename ` - вернет истину, если `filename` существует и доступен для чтения.
- `-w filename ` - вернет истину, если `filename` существует и доступен для записи.
- ` -x filename ` - вернет истину, если `filename` существует и доступен для выполнения.
- ` filename1 -nt filename2 ` - вернет истину, если `filename1` новее (дата модификации), чем `filename2`.
- ` filename1 -ot filename2 ` - вернет истину, если `filename1` старее, чем `filename2`.

Пример:
```
if [ -e "folder/.vimrc" ]; then echo Существует; else echo Не существует; fi
```

#### Сравнение целочисленных значений
Пишем `num1 -<flag> num2`, где вместо `<flag>` пишем:
- `eq` (equal) - истина в случае равенства значений (==)
- `ne` (not equal) - истина в случае НЕравенства значений (!=)
- `lt` (less than) - истина в случае возрастания значений (<)
- `le` (less or equal) - истина в случае НЕубывания значений (<=)
- `gt` (greater than) - истина в случае убывания значений (>)
- `ge` (greater or equal) - истина в случае НЕвозрастания значений (>=)

Пример:
```
if [ 2 -ge 4 ]; then echo База; else echo Кринж; fi
```

#### Сравнение строковых значений
- ` -z string ` - вернет истину, если длина `string` = 0.
- ` -n string ` - вернет истину, если длина `string` != 0.
- ` string1 = string2 ` - вернет истину при равенстве строк.
- ` string1 != string2 ` - вернет истину при НЕравенстве строк.

#### AND, OR и NOT
- `expr1 -a expr2 ` - AND - истина в случае истинности обоих выражений.
- `expr1 -o expr2 ` - OR - истина в случае истинности хотя бы одного из выражений
- `! expr` - NOT - истина в случае ложности выражения.

#### Изменение порядка вычисления выражений
Используем для этого **экранированные** круглые скобки: `\(` и `\)`.

Пример:
```
[ \( 14 -ge 0 \) -a \( -z "$st" \) ]
```

#### Двойные квадратные скобочки

Отличается от одинарных скобочек тем, что внутри них можно использовать операторы `&&` и `||`. 

## Другие интересные команды

### seq (SEQuence)
Генерирует арифметическую прогрессию.
```
$ seq <start> <incr> <stop>
```

Пример:
```
$ seq 1 2 24
1
3
5
7
9
11
13
15
17
19
21
23
```

### head (HEAD ¯\\\_(ツ)_/¯)
Выводит строки в начале объекта или нескольких объектов (по умолчанию - 10).

```
$ head <flags> <file1> <file2> ...
```

При помощи флага `-n` можно изменить количество строк: 
```
$ head -n 5 arif.txt
```

Пример использования с командой `seq`:
```
$ seq 1 2 24 | head -n 5
1
3
5
7
9
```

### tail (TAIL ¯\\\_(ツ)_/¯)
Выводит строки в конце объекта или нескольких объектов (по умолчанию - 10).

```
$ tail <flags> <file1> <file2> ...
```

При помощи флага `-n` можно изменить количество строк: 
```
$ tail -n 5 arif.txt
```

Пример использования с командой `seq`:
```
$ seq 1 2 24 | tail -n 5
15
17
19
21
23

$ seq 1 2 24 | head -n 5 | tail -n 3
5
7
9
```

## vim (VI iMproved)
Один из лучших текстовых редакторов ever. Почему? А потому:
1. Широкие возможности кастомизации
2. Несчетное множество плагинов
3. Быстро работает на любом компе
4. Порог вхождения, конечно, высок, но зато вы будете кодить *КАК БОГ* ~~и получать 300к в сек~~. То, что делается в привычных редакторах кода в несколько кликов, здесь реализуется за одну простую команду.

Запустить vim:
```
$ vim <flags> <filename>
```

Как правило, предустановлен на каждой linux-машине. Поэтому бегом [смотреть эту замечательную инструкцию по настройке vim'а.](https://habr.com/ru/articles/468265/)

## GDB (GNU Debugger)

Стандартный отладчик для программ на языках Си и C++. Как правило, поставляется вместе с linux (хотя иногда вместо GDB может стоять LLDB).

Зачем нужен отладчик? Затем, чтобы:

1. Выполнить программу по шагам
2. Видеть значения переменной на каждом шаге
3. Дизассемблировать код и проверить состояния регистров

Если вы дошли до конца второго семестра и до сих пор не знаете о том, как отладчик спасает ~~жизни~~ нервные клетки прогеров, то я вам *сочувствую*...

К сожалению, автору было лень расписывать все команды в этом и так огроменном файле. [Поэтому гайд по GDB смотри здесь...](https://losst.pro/kak-polzovatsya-gdb?ysclid=lkfuz58qlm910824171)